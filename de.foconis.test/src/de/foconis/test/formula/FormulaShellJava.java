/* Generated By:JJTree&JavaCC: Do not edit this line. AtFormulaParser.java */
package de.foconis.test.formula;

import java.io.File;
import java.util.Collection;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;

import jline.ArgumentCompletor;
import jline.Completor;
import jline.ConsoleReader;
import jline.SimpleCompletor;

import org.openntf.formula.ASTNode;
import org.openntf.formula.EvaluateException;
import org.openntf.formula.FormulaContext;
import org.openntf.formula.FormulaParseException;
import org.openntf.formula.FormulaParser;
import org.openntf.formula.Formulas;
import org.openntf.formula.Function;
import org.openntf.formula.FunctionFactory;

public class FormulaShellJava extends TestRunnerCommon {

	public static void main(final String[] args) {
		Thread thread = new Thread(new FormulaShellJava(), "My thread");
		thread.start();
	}

	public FormulaShellJava() {
		// whatever you might want to do in your constructor, but stay away from Domino objects
	}

	@Override
	public void run() {
		try {

			// RPr: I use  "http://jline.sourceforge.net/" to emulate a shell to test my formula engine
			// I put jline-1.0.jar in jvm/lib/ext
			// In detail: I do not know exactly what I'm doing here... I just need a shell :) 

			ConsoleReader reader = new ConsoleReader();
			reader.setBellEnabled(false);
			//reader.setDebug(new PrintWriter(new FileWriter("writer.debug", true)));

			List<Completor> completors = new LinkedList<Completor>();

			// This code is responsible for autocompletion
			FunctionFactory funcFact = Formulas.getFunctionFactory();
			Collection<Function> funcs = funcFact.getFunctions().values();
			String[] autoComplete = new String[funcs.size() + 3];
			int i = 0;
			for (Function func : funcs) {
				//if (func instanceof NotImplemented) {
				//	autoComplete[i++] = "NotImpl:" + func.getImage();
				//} else {
				autoComplete[i++] = func.getImage() + "(";
				//}
			}
			autoComplete[i++] = "count=";
			autoComplete[i++] = "astoff";
			autoComplete[i++] = "aston";
			completors.add(new SimpleCompletor(autoComplete));
			reader.addCompletor(new ArgumentCompletor(completors));

			String line;
			// we want some more comfort
			File historyFile = new File("history.txt");
			reader.getHistory().setHistoryFile(historyFile);

			// now start the main loop
			System.out.println("This is the formula shell. Quit with 'q' !!!");
			//System.out.println("AST-Cache is " + LOTUS(cacheAST ? "on" : "off"));
			//System.out.println("Iteration count is " + LOTUS(cacheAST ? "on" : "off"));

			while ((line = reader.readLine("$> ")) != null) {
				//				if (line.startsWith("count")) {
				//					int p = line.indexOf('=');
				//					count = Integer.parseInt(line.substring(p + 1));
				//					System.out.println("Iteration count is set to: " + LOTUS(count));
				//					continue;
				//				}
				//				if (line.equalsIgnoreCase("astoff")) {
				//					cacheAST = false;
				//					System.out.println("AST Cache is set to off");
				//					continue;
				//				}

				//				if (line.equalsIgnoreCase("aston")) {
				//					cacheAST = true;
				//					astCache = new HashMap<String, Node>();
				//					System.out.println("AST Cache is set to on");
				//					continue;
				//				}
				if (line.equalsIgnoreCase("q")) {
					break;
				}

				try {
					// disabled lotus!
					execute(line);
				} catch (Exception e) {
					e.printStackTrace();
				}
			}
			System.out.println("Bye.");

		} catch (Exception e) {
			e.printStackTrace();
		}

	}

	protected void execute(final String line) {
		// TODO Auto-generated method stub

		List<Object> ntfMapResult = null;
		Throwable ntfError = null;

		boolean parserFailed = false;
		// Setup procedure, prepare the demo docs & maps
		StringBuffer errors = new StringBuffer();

		double rnd = Math.random();

		Map<String, Object> ntfMap = new HashMap<String, Object>();

		fillDemoDoc(ntfMap, rnd);

		// benchmark the AtFormulaParser
		ASTNode ast = null;
		FormulaParser parser = Formulas.getParser();
		try {
			ast = parser.parse(line);
		} catch (FormulaParseException e) {
			errors.append(NTF("\tParser failed: ") + ERROR(e) + "\n");
			e.printStackTrace();
			parserFailed = true;
		} catch (Throwable t) {
			System.err.println(ERROR("FATAL") + NTF("\tParser failed: ") + ERROR(t));
			t.printStackTrace();
		}

		if (!parserFailed) {
			try {
				// benchmark the evaluate with a map as context
				FormulaContext ctx2 = Formulas.createContext(ntfMap, parser);
				ntfMapResult = ast.solve(ctx2);
			} catch (EvaluateException e) {
				errors.append(NTF("\tMap-Evaluate failed: ") + ERROR(e) + "\n");
				ntfError = e;
				parserFailed = true;
			} catch (Throwable t) {
				System.err.println(ERROR("FATAL") + NTF("\tMap-Evaluate failed: ") + ERROR(t));
				t.printStackTrace();
			}
		}

		if (parserFailed) {
			ntfError.printStackTrace();
		}
		System.err.println("\tMapResult:   " + dump(ntfMapResult) + " Size: " + ((ntfMapResult == null) ? 0 : ntfMapResult.size()));
		System.out.println(NTF("Read fields\t") + ast.getReadFields());
		System.out.println(NTF("Modified fields\t") + ast.getModifiedFields());
		System.out.println(NTF("Variables\t") + ast.getVariables());
		System.out.println(NTF("Functions\t") + ast.getFunctions());

	}

}
