options{  STATIC = false;  JAVA_UNICODE_ESCAPE = false; // Should not pre parse the unicode escape  UNICODE_INPUT = true; // Should accept unicode character from the Reader  JDK_VERSION = "1.5";  IGNORE_CASE = true;  MULTI = true;  NODE_DEFAULT_VOID = true;  NODE_USES_PARSER = true; // needed to query for formula extensions  NODE_PACKAGE = "org.openntf.domino.formula.ast";  OUTPUT_DIRECTORY = "..";  JJTREE_OUTPUT_DIRECTORY = "ast";}PARSER_BEGIN(AtFormulaParser)/* * © Copyright FOCONIS AG, 2014 *  * Licensed under the Apache License, Version 2.0 (the "License");  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at: *  * http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or  * implied. See the License for the specific language governing  * permissions and limitations under the License. */package org.openntf.domino.formula;import java.util.HashMap;import java.util.Map;import org.openntf.domino.formula.AtFunction;import org.openntf.domino.formula.Formatter;import org.openntf.domino.formula.AtFunctionFactory;public class AtFormulaParser{  protected Formatter formatter;  protected AtFunctionFactory functionFactory;  protected Map<String, AtFunction> customFunc = new HashMap<String, AtFunction>();  	    public AtFormulaParser(Formatter fmt, AtFunctionFactory fact) {    this(new java.io.StringReader("")); // needed for proper init :(    formatter = fmt;    functionFactory = fact;  }      public Formatter getFormatter() {	return formatter;  }    public AtFunction getFunction(String string) {	AtFunction func = functionFactory.getFunction(string);	if (func != null) {		return func;    }	return customFunc.get(string.toLowerCase());    }  public void declareFunction(String funcName, AtFunction func)  {    if (getFunction(funcName) != null) {		throw new IllegalArgumentException("Function '" + funcName + "' cannot be redeclared");    }  	customFunc.put(funcName.toLowerCase(), func);     }    }PARSER_END(AtFormulaParser)/*	public String toString() {		return AdderTreeConstants.jjtNodeName[id] + ": " + jjtGetValue();	}*//** * Lexer rules */// in default mode, a "[" means that the string to the "]" is a Date or Keyword< DEFAULT > TOKEN :{	< Date_or_KW : "[" (~["]"])* "]" > : SUBSCRIPT	// after a Date, we are in "subscript" mode (e.g. [Today][1])}// in subscript mode, a "[" means that the following expression is a subscript// a subscript can occur after a numeric value, a string, a ")", a date, an identifier or an other subscript< SUBSCRIPT > TOKEN :{  	 < OSubscript : "[" > 	:  DEFAULT		// switch back immediately. Thus x[[today]] makes no sense, it is formal correct}< DEFAULT, SUBSCRIPT > TOKEN :{  	// "]" must be recognized in both states  	// consider these examples "x[(1)]": the ) switches to "SUBSCRIPT" 	< CSubscript : "]" > :  SUBSCRIPT	 }< DEFAULT, SUBSCRIPT >TOKEN :{  	// misc tokens	< EOS : ";" >								:	DEFAULT // End of Statement| 	< OParen : "(" >							: 	DEFAULT| 	< CParen : ")" >							: 	SUBSCRIPT // the next open [ means, that this is a subscript| 	< Assign : ":=" >							:	DEFAULT| 	< BoolNot : "!" >							: 	DEFAULT	// Keywords| 	< KW_DEFAULT	: "DEFAULT" >| 	< KW_ENVIRONMENT: "ENVIRONMENT" >| 	< KW_FIELD 		: "FIELD" >| 	< KW_REM 		: "REM" >| 	< KW_SELECT		: "SELECT" >	// @Functions| 	< At_do			: "@do" > | 	< At_doWhile	: "@doWhile" > | 	< At_for		: "@for" > | 	< At_if			: "@if" >| 	< At_v2if		: "@V2if" >| 	< At_iferror	: "@iferror" > | 	< At_transform	: "@transform" > 	// All other at functions that does not control program flow| 	< At_other 	: "@" ( < Letter >  )  (  < Letter >  | < Digit > )*  > : SUBSCRIPT // switch to subscript, to handle @dbname[2]	// Precedence 2| 	< ListConcat : ":" > : DEFAULT	// Precedence 3 (= signs, not listed here)	// < OpPlus : "+" >	// < OpMinus : "-" >			// Precedence 4| 	< OpMul : "*" >		: DEFAULT | 	< OpMulP : "**" >	: DEFAULT | 	< OpDiv : "/" >		: DEFAULT | 	< OpDivP : "*/" >	: DEFAULT 	// Precedence 5| 	< OpPlus : "+" > 	: DEFAULT| 	< OpPlusP : "*+" > 	: DEFAULT| 	< OpMinus : "-" > 	: DEFAULT| 	< OpMinusP : "*-" > : DEFAULT	// Precedence 6 - all compare operations|   < CmpEqual : "=" >						: DEFAULT| 	< CmpEqualP : "*=" >					: DEFAULT| 	< CmpNE : "<>" | "!=" | "=!" | "><" >	: DEFAULT| 	< CmpNEP : "*<>" >						: DEFAULT| 	< CmpLT : "<" >							: DEFAULT| 	< CmpLTP : "*<" >						: DEFAULT| 	< CmpGT : ">" >							: DEFAULT| 	< CmpGTP : "*>" >						: DEFAULT| 	< CmpLTE : "<=" >						: DEFAULT| 	< CmpLTEP : "*<=" >						: DEFAULT| 	< CmpGTE : ">=" >						: DEFAULT| 	< CmpGTEP : "*>=" >						: DEFAULT		// Precedence 7| 	< BoolAnd : "&" > : DEFAULT| 	< BoolOr : "|" > : DEFAULT	// Numbers: TODO: Why are they locale dependent???	// Thousands separator must be avoided!|	< NumDoubleUS 	:	(< Digit >)* "." (< Digit >)+ (< Exponent >)? > : SUBSCRIPT | 	< NumDoubleDE 	:	(< Digit >)* "," (< Digit >)+ (< Exponent >)? > : SUBSCRIPT | 	< NumInteger 	: 	(< Digit >)+ ("."|",")? (< Exponent >)? > : SUBSCRIPT | 	< #Exponent: ["e","E"] (["+","-"])? (< Digit >)+ >	// Strings| 	< String1 : "\""		 	// Start at "        	(~["\""] 			// until " or \         	| "\\\""				// but not \ (escaped)        	 )*  "\"" > : SUBSCRIPT			// end at "        	 | 	< String2 : "{"		 		// Start at {          	(~["}"])*			// until  }          	"}" >  : SUBSCRIPT	// end at "| 	< Identifier :  ( < Letter >  )  (  < Letter >  | < Digit > )* > : SUBSCRIPT// Common groups| < #Letter:      [       "\u0024",			// $       "\u0041"-"\u005a",	// A-Z       "\u005f",			// _       "\u0061"-"\u007a",	// a-z       "\u007e",			// ~       "\u00c0"-"\u00d6",	// À - Ö       "\u00d8"-"\u00f6",	// Ø - ö       "\u00f8"-"\u00ff",	// ø - ÿ       "\u0100"-"\u1fff",	// Latin Extended - A       "\u3040"-"\u318f",	// HIRAGANA/KATAKANA LETTER       "\u3300"-"\u337f",	// CJK Compatibility       "\u3400"-"\u3d2d",	// CJK Unified ideograps Extension A       "\u4e00"-"\u9fff",	// CJK Unified ideograps Extension A       "\uf900"-"\ufaff"	// CJK ... other      ]  >|  < #Digit:      [       "\u0030"-"\u0039"// 	RPr/JSt: only arabic digits are supported       //       "\u0660"-"\u0669",//       "\u06f0"-"\u06f9",//       "\u0966"-"\u096f",//       "\u09e6"-"\u09ef",//       "\u0a66"-"\u0a6f",//       "\u0ae6"-"\u0aef",//       "\u0b66"-"\u0b6f",//       "\u0be7"-"\u0bef",//       "\u0c66"-"\u0c6f",//       "\u0ce6"-"\u0cef",//       "\u0d66"-"\u0d6f",//       "\u0e50"-"\u0e59",//       "\u0ed0"-"\u0ed9",//       "\u1040"-"\u1049"      ]  >}  < * >SKIP :	{  " "| "\t"| "\n"| "\r"| "\r\n"}/** * Parser rules javacc options *//** * parses expressions. Expressions must not end with ";" (=< EOS >) */public SimpleNode Parse() #AtDo :{} {	(< EOS >)*	(	  	< KW_REM > 	comment()  // AFAIK REMS are only allowed at top level 		|			statement()	)	(	  	(< EOS >)+	 	(	 	  	< KW_REM > comment()  // AFAIK REMS are only allowed at top level 	  	|	statement()	  	)	)* < EOF >  {  return jjtThis; }}private void comment() :{}{		< String1 >	| 	< String2 >	|  	< OParen > comment() < CParen >}/** * an expression is one of the 3 "set" keywords (DEFAULT/FIELD/ENVIRONMENT) to set Fields/Env * or an identifier to set a variable. Special case for SELECT  */ private void statement() :{ Token t; }{ //LOOKAHEAD(3) 	< KW_FIELD > 		(t = < Identifier > < Assign > {jjtThis.init(t.image, ASTAssignment.FIELD);		} opBool()) 	#Assignment|  	LOOKAHEAD(2) 		(t = < Identifier > < Assign > {jjtThis.init(t.image, ASTAssignment.VAR);		} opBool()) 	#Assignment| 	< KW_ENVIRONMENT > 	(t = < Identifier > < Assign > {jjtThis.init(t.image, ASTAssignment.ENV);		} opBool()) 	#Assignment| 	< KW_DEFAULT > 		(t = < Identifier > < Assign > {jjtThis.init(t.image, ASTAssignment.DEFAULT);	} opBool()) 	#Assignment| 	< KW_SELECT > opBool() 									#Select| 	opBool()}  /** * boolean ops has the lowest precedence, * ATTENTION: Formula language is the only language I know, where AND and OR has the same precedence! */private void opBool() :{ }{  opCmp() (    (    		< BoolAnd > opCmp() {jjtThis.setFunction("_and");	}    	| 	< BoolOr >  opCmp() {jjtThis.setFunction("_or");	}  	  	) #Operator(2)  )*}/** * before boolean, all compares are evaluated */private void opCmp()  :{ }{  opAdd()  (    (     		< CmpEqual > 	opAdd() {jjtThis.setFunction("_cmpEq")		;}    	| 	< CmpEqualP > 	opAdd() {jjtThis.setFunction("_cmpEqP")		;}     	| 	< CmpNE > 		opAdd() {jjtThis.setFunction("_cmpNe")		;}     	| 	< CmpNEP > 		opAdd() {jjtThis.setFunction("_cmpNeP")		;}     	| 	< CmpLT > 		opAdd() {jjtThis.setFunction("_cmpLt")		;}     	| 	< CmpLTP > 		opAdd() {jjtThis.setFunction("_cmpLtP")		;}    	| 	< CmpGT > 		opAdd() {jjtThis.setFunction("_cmpGt")		;}     	| 	< CmpGTP > 		opAdd() {jjtThis.setFunction("_cmpGtP")		;}     	| 	< CmpLTE > 		opAdd() {jjtThis.setFunction("_cmpLte")		;}     	| 	< CmpLTEP > 	opAdd() {jjtThis.setFunction("_cmpLteP")	;}     	| 	< CmpGTE > 		opAdd() {jjtThis.setFunction("_cmpGte")		;}     	| 	< CmpGTEP > 	opAdd() {jjtThis.setFunction("_cmpGteP")	;}    ) #Operator(2))*}/** * next precedence are all add/subtract operations */private void opAdd() :{ }{    opMult()  (LOOKAHEAD(2) ( // lookahead 2 is required, to determine if it is a sign 			< OpPlus >	 	opMult() {jjtThis.setFunction("_add")	;} 		| 	< OpPlusP >		opMult() {jjtThis.setFunction("_addP")	;} 		| 	< OpMinus > 	opMult() {jjtThis.setFunction("_sub")	;} 		| 	< OpMinusP > 	opMult() {jjtThis.setFunction("_subP")	;} 	) #Operator(2)  )*}/** * highest precedence of operations is multiplication. This is done with a unary list */private void opMult()  :{ }{  valueList()  (    (      		< OpMul > 	valueList()  {jjtThis.setFunction("_mul")	;}     	|	< OpMulP > 	valueList()  {jjtThis.setFunction("_mulP")	;}      	| 	< OpDiv > 	valueList()  {jjtThis.setFunction("_div")	;}      	| 	< OpDivP > 	valueList()  {jjtThis.setFunction("_divP")	;}	) #Operator(2) ) *}/** * one ore more values * for saving mem, unaries are wrapped only in a valueList, if there are more than once */private void valueList() :{}{	(subscript() (< ListConcat > subscript())* ) #ValueList(>1)  }private void subscript() :{}{  	(unary()  (< OSubscript > statement() < CSubscript >)*) #Subscript(>1)}private void unary() :{}{ 	< OpPlus > unary() | 	< OpMinus > unary() {jjtThis.setFunction("_negative")	;} #Operator(1)| 	< BoolNot > unary() {jjtThis.setFunction("_not")		;} #Operator(1)// All control flow functions| < At_do > 		(< OParen >  statement() ( < EOS > statement() )*  < CParen >) #AtDo| < At_doWhile > 	(< OParen >  statement() ( < EOS > statement() )*  < CParen >) #AtDoWhile| < At_for >		(< OParen >  	statement()	// initialize						< EOS >		statement()	// condition						< EOS >		statement() 	// increment						( < EOS > 	statement() )*	// statements					 < CParen >) #AtFor| (< At_if > | < At_v2if > )					(< OParen >  	statement()	// if						( < EOS > 	statement() < EOS > statement())+	// the elese(if)					 < CParen >) #AtIf					 | < At_iferror >	(< OParen >  	statement() (< EOS > statement())? < CParen >) #AtIfError| < At_transform >	(< OParen >  	statement()	// list						< EOS >		statement()	// varName						< EOS >		statement() 	// formula					 < CParen >) #AtTranform	 | < At_other > formula() | atom()}private void formula() #Function :{}{  { jjtThis.setFunction(getToken(0).image); }  // Optional parameters.   ( LOOKAHEAD(2)  	< OParen >    	  statement() ( < EOS > statement() )*    < CParen >  )?   }private void atom() :{}{   value()| < OParen > statement() <CParen >}/*private void setDefault() #SetDefault :{    Token t;}{	t = <Identifier >	< Assign > opBool()	{ jjtThis.value = t.image; }}private void setEnvironment() #SetEnvironment :{    Token t;}{	t = <Identifier >	< Assign > opBool()	{ jjtThis.value = t.image; }}private void setField() #SetField :{    Token t;}{	t = <Identifier >	< Assign > opBool()	{ jjtThis.value = t.image; }}private void setVariable() #SetVariable :{}{	opBool()	{ jjtThis.value =  getToken(0).image; }}*/private void value()  :{  Token t;}{  	t = < Date_or_KW >  	{ jjtThis.init(t.image); } #ValueDateOrKW|	t = < String1 >  	{ jjtThis.parseString(t.image, '"'); } #ValueString|	t = < String2 >  	{ jjtThis.parseString(t.image, '{' ); } #ValueString|	t = < NumDoubleUS >  	{ jjtThis.parseDouble(t.image,'.'); } #ValueDouble|	t = < NumDoubleDE >  	{ jjtThis.parseDouble(t.image,','); } #ValueDouble|	t = < NumInteger >  	{ jjtThis.parseLong(t.image); } #ValueLong|	t = < Identifier >  	{ jjtThis.init(t.image); } #GetVariable	}