/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. atFormula.jj */
/*@egen*/options{  STATIC = false;  JAVA_UNICODE_ESCAPE = false; // Should not pre parse the unicode escape  UNICODE_INPUT = true; // Should accept unicode character from the Reader  JDK_VERSION = "1.5";  IGNORE_CASE = true;                                                                                                                                                                  OUTPUT_DIRECTORY = "..";                                  }PARSER_BEGIN(AtFormulaParser)/* * \u00c2\u00a9 Copyright FOCONIS AG, 2014 *  * Licensed under the Apache License, Version 2.0 (the "License");  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at: *  * http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or  * implied. See the License for the specific language governing  * permissions and limitations under the License. */package org.openntf.domino.formula;
import org.openntf.domino.formula.ast.*;
import java.util.HashMap;import java.util.Map;import org.openntf.domino.formula.AtFunction;import org.openntf.domino.formula.Formatter;import org.openntf.domino.formula.AtFunctionFactory;import org.openntf.domino.utils.Factory;import org.openntf.domino.utils.Terminatable;public class AtFormulaParser/*@bgen(jjtree)*/implements AtFormulaParserTreeConstants/*@egen*/{/*@bgen(jjtree)*/
  protected JJTAtFormulaParserState jjtree = new JJTAtFormulaParserState();

/*@egen*/  protected Formatter formatter;  protected AtFunctionFactory functionFactory;  protected Map<String, AtFunction> customFunc = new HashMap<String, AtFunction>();  private static ThreadLocal<AtFormulaParser> instance_ = new ThreadLocal<AtFormulaParser>() {		@Override		protected AtFormulaParser initialValue() {			return new AtFormulaParser(DominoFormatter.getInstance(), AtFunctionFactory.getInstance());		}  };  static {		Factory.onTerminate(new Terminatable() {			public void terminate() {				instance_.set(null);			}		});  }      	    public AtFormulaParser(Formatter fmt, AtFunctionFactory fact) {    this(new java.io.StringReader("")); // needed for proper init :(    formatter = fmt;    functionFactory = fact;  }      public Formatter getFormatter() {	return formatter;  }  /**   * This function returns a preconfigured default instance   */  public static AtFormulaParser getInstance() {	return instance_.get();  }    public AtFunction getFunction(String string) {	AtFunction func = functionFactory.getFunction(string);	if (func != null) {		return func;    }	return customFunc.get(string.toLowerCase());    }  public void declareFunction(String funcName, AtFunction func)  {    if (getFunction(funcName) != null) {		throw new IllegalArgumentException("Function '" + funcName + "' cannot be redeclared");    }  	customFunc.put(funcName.toLowerCase(), func);     }  final public SimpleNode Parse(final String formula) throws ParseException {	java.io.StringReader sr = new java.io.StringReader(formula);	ReInit(sr);	return Parse();  }    }PARSER_END(AtFormulaParser)/*	public String toString() {		return AdderTreeConstants.jjtNodeName[id] + ": " + jjtGetValue();	}*//** * Lexer rules */// in default mode, a "[" means that the string to the "]" is a Date or Keyword< DEFAULT > TOKEN :{	< Date_or_KW : "[" (~["]"])* "]" > : SUBSCRIPT	// after a Date, we are in "subscript" mode (e.g. [Today][1])}// in subscript mode, a "[" means that the following expression is a subscript// a subscript can occur after a numeric value, a string, a ")", a date, an identifier or an other subscript< SUBSCRIPT > TOKEN :{  	 < OSubscript : "[" > 	:  DEFAULT		// switch back immediately. Thus x[[today]] makes no sense, it is formal correct}< DEFAULT, SUBSCRIPT > TOKEN :{  	// "]" must be recognized in both states  	// consider these examples "x[(1)]": the ) switches to "SUBSCRIPT" 	< CSubscript : "]" > :  SUBSCRIPT	 }< DEFAULT, SUBSCRIPT >TOKEN :{  	// misc tokens	< EOS : ";" >								:	DEFAULT // End of Statement| 	< OParen : "(" >							: 	DEFAULT| 	< CParen : ")" >							: 	SUBSCRIPT // the next open [ means, that this is a subscript| 	< Assign : ":=" >							:	DEFAULT| 	< BoolNot : "!" >							: 	DEFAULT	// Keywords| 	< KW_DEFAULT	: "DEFAULT" >| 	< KW_ENVIRONMENT: "ENVIRONMENT" >| 	< KW_FIELD 		: "FIELD" >| 	< KW_REM 		: "REM" >| 	< KW_SELECT		: "SELECT" >	// @Functions| 	< At_do			: "@do" > | 	< At_doWhile	: "@doWhile" > | 	< At_for		: "@for" > | 	< At_if			: "@if" >| 	< At_v2if		: "@V2if" >| 	< At_iferror	: "@iferror" > | 	< At_transform	: "@transform" > 	// All other at functions that does not control program flow| 	< At_other 	: "@" ( < Letter >  )  (  < Letter >  | < Digit > )*  > : SUBSCRIPT // switch to subscript, to handle @dbname[2]	// Precedence 2| 	< ListConcat : ":" > : DEFAULT	// Precedence 3 (= signs, not listed here)	// < OpPlus : "+" >	// < OpMinus : "-" >			// Precedence 4| 	< OpMul : "*" >		: DEFAULT | 	< OpMulP : "**" >	: DEFAULT | 	< OpDiv : "/" >		: DEFAULT | 	< OpDivP : "*/" >	: DEFAULT 	// Precedence 5| 	< OpPlus : "+" > 	: DEFAULT| 	< OpPlusP : "*+" > 	: DEFAULT| 	< OpMinus : "-" > 	: DEFAULT| 	< OpMinusP : "*-" > : DEFAULT	// Precedence 6 - all compare operations|   < CmpEqual : "=" >						: DEFAULT| 	< CmpEqualP : "*=" >					: DEFAULT| 	< CmpNE : "<>" | "!=" | "=!" | "><" >	: DEFAULT| 	< CmpNEP : "*<>" >						: DEFAULT| 	< CmpLT : "<" >							: DEFAULT| 	< CmpLTP : "*<" >						: DEFAULT| 	< CmpGT : ">" >							: DEFAULT| 	< CmpGTP : "*>" >						: DEFAULT| 	< CmpLTE : "<=" >						: DEFAULT| 	< CmpLTEP : "*<=" >						: DEFAULT| 	< CmpGTE : ">=" >						: DEFAULT| 	< CmpGTEP : "*>=" >						: DEFAULT		// Precedence 7| 	< BoolAnd : "&" > : DEFAULT| 	< BoolOr : "|" > : DEFAULT	// Numbers: TODO: Why are they locale dependent???	// Thousands separator must be avoided!|	< NumDoubleUS 	:	(< Digit >)* "." (< Digit >)+ (< Exponent >)? > : SUBSCRIPT | 	< NumDoubleDE 	:	(< Digit >)* "," (< Digit >)+ (< Exponent >)? > : SUBSCRIPT | 	< NumInteger 	: 	(< Digit >)+ ("."|",")? (< Exponent >)? > : SUBSCRIPT | 	< #Exponent: ["e","E"] (["+","-"])? (< Digit >)+ >	// Strings| 	< String1 : "\""		 	// Start at "        	(~["\""] 			// until " or \         	| "\\\""				// but not \ (escaped)        	 )*  "\"" > : SUBSCRIPT			// end at "        	 | 	< String2 : "{"		 		// Start at {          	(~["}"])*			// until  }          	"}" >  : SUBSCRIPT	// end at "| 	< Identifier :  ( < Letter >  )  (  < Letter >  | < Digit > )* > : SUBSCRIPT// Common groups| < #Letter:      [       "$",			// $       "A"-"Z",	// A-Z       "_",			// _       "a"-"z",	// a-z       "~",			// ~       "\u00c0"-"\u00d6",	// \u00c3\u20ac - \u00c3\u2013       "\u00d8"-"\u00f6",	// \u00c3\u02dc - \u00c3\u00b6       "\u00f8"-"\u00ff",	// \u00c3\u00b8 - \u00c3\u00bf       "\u0100"-"\u1fff",	// Latin Extended - A       "\u3040"-"\u318f",	// HIRAGANA/KATAKANA LETTER       "\u3300"-"\u337f",	// CJK Compatibility       "\u3400"-"\u3d2d",	// CJK Unified ideograps Extension A       "\u4e00"-"\u9fff",	// CJK Unified ideograps Extension A       "\uf900"-"\ufaff"	// CJK ... other      ]  >|  < #Digit:      [       "0"-"9"// 	RPr/JSt: only arabic digits are supported       //       "\u0660"-"\u0669",//       "\u06f0"-"\u06f9",//       "\u0966"-"\u096f",//       "\u09e6"-"\u09ef",//       "\u0a66"-"\u0a6f",//       "\u0ae6"-"\u0aef",//       "\u0b66"-"\u0b6f",//       "\u0be7"-"\u0bef",//       "\u0c66"-"\u0c6f",//       "\u0ce6"-"\u0cef",//       "\u0d66"-"\u0d6f",//       "\u0e50"-"\u0e59",//       "\u0ed0"-"\u0ed9",//       "\u1040"-"\u1049"      ]  >}  < * >SKIP :	{  " "| "\t"| "\n"| "\r"| "\r\n"}/** * Parser rules javacc options *//** * parses expressions. Expressions must not end with ";" (=< EOS >) */public SimpleNode Parse()       :{/*@bgen(jjtree) AtDo */
  ASTAtDo jjtn000 = new ASTAtDo(this, JJTATDO);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) AtDo */
        try {
/*@egen*/	(< EOS >)*	(	  	< KW_REM > 	comment()  // AFAIK REMS are only allowed at top level 		|			statement()	)	(	  	(< EOS >)+	 	(	 	  	< KW_REM > comment()  // AFAIK REMS are only allowed at top level 	  	|	statement()	  	)	)* < EOF >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {  return jjtn000; }/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/}private void comment() :{}{		< String1 >	| 	< String2 >	|  	< OParen > comment() < CParen >}/** * an expression is one of the 3 "set" keywords (DEFAULT/FIELD/ENVIRONMENT) to set Fields/Env * or an identifier to set a variable. Special case for SELECT  */ private void statement() :{ Token t; }{ //LOOKAHEAD(3) 	< KW_FIELD >/*@bgen(jjtree) Assignment */
                                {
                                  ASTAssignment jjtn001 = new ASTAssignment(this, JJTASSIGNMENT);
                                  boolean jjtc001 = true;
                                  jjtree.openNodeScope(jjtn001);
                                }
                                try {
/*@egen*/ 		(t = < Identifier > < Assign > {jjtn001.init(t.image, ASTAssignment.FIELD);		} opBool())/*@bgen(jjtree)*/
                                } catch (Throwable jjte001) {
                                  if (jjtc001) {
                                    jjtree.clearNodeScope(jjtn001);
                                    jjtc001 = false;
                                  } else {
                                    jjtree.popNode();
                                  }
                                  if (jjte001 instanceof RuntimeException) {
                                    throw (RuntimeException)jjte001;
                                  }
                                  if (jjte001 instanceof ParseException) {
                                    throw (ParseException)jjte001;
                                  }
                                  throw (Error)jjte001;
                                } finally {
                                  if (jjtc001) {
                                    jjtree.closeNodeScope(jjtn001, true);
                                  }
                                }
/*@egen*/ 	           |  	LOOKAHEAD(2)/*@bgen(jjtree) Assignment */
                                {
                                  ASTAssignment jjtn002 = new ASTAssignment(this, JJTASSIGNMENT);
                                  boolean jjtc002 = true;
                                  jjtree.openNodeScope(jjtn002);
                                }
                                try {
/*@egen*/ 		(t = < Identifier > < Assign > {jjtn002.init(t.image, ASTAssignment.VAR);		} opBool())/*@bgen(jjtree)*/
                                } catch (Throwable jjte002) {
                                  if (jjtc002) {
                                    jjtree.clearNodeScope(jjtn002);
                                    jjtc002 = false;
                                  } else {
                                    jjtree.popNode();
                                  }
                                  if (jjte002 instanceof RuntimeException) {
                                    throw (RuntimeException)jjte002;
                                  }
                                  if (jjte002 instanceof ParseException) {
                                    throw (ParseException)jjte002;
                                  }
                                  throw (Error)jjte002;
                                } finally {
                                  if (jjtc002) {
                                    jjtree.closeNodeScope(jjtn002, true);
                                  }
                                }
/*@egen*/ 	           | 	< KW_ENVIRONMENT >/*@bgen(jjtree) Assignment */
                                {
                                  ASTAssignment jjtn003 = new ASTAssignment(this, JJTASSIGNMENT);
                                  boolean jjtc003 = true;
                                  jjtree.openNodeScope(jjtn003);
                                }
                                try {
/*@egen*/ 	(t = < Identifier > < Assign > {jjtn003.init(t.image, ASTAssignment.ENV);		} opBool())/*@bgen(jjtree)*/
                                } catch (Throwable jjte003) {
                                  if (jjtc003) {
                                    jjtree.clearNodeScope(jjtn003);
                                    jjtc003 = false;
                                  } else {
                                    jjtree.popNode();
                                  }
                                  if (jjte003 instanceof RuntimeException) {
                                    throw (RuntimeException)jjte003;
                                  }
                                  if (jjte003 instanceof ParseException) {
                                    throw (ParseException)jjte003;
                                  }
                                  throw (Error)jjte003;
                                } finally {
                                  if (jjtc003) {
                                    jjtree.closeNodeScope(jjtn003, true);
                                  }
                                }
/*@egen*/ 	           | 	< KW_DEFAULT >/*@bgen(jjtree) Assignment */
                                {
                                  ASTAssignment jjtn004 = new ASTAssignment(this, JJTASSIGNMENT);
                                  boolean jjtc004 = true;
                                  jjtree.openNodeScope(jjtn004);
                                }
                                try {
/*@egen*/ 		(t = < Identifier > < Assign > {jjtn004.init(t.image, ASTAssignment.DEFAULT);	} opBool())/*@bgen(jjtree)*/
                                } catch (Throwable jjte004) {
                                  if (jjtc004) {
                                    jjtree.clearNodeScope(jjtn004);
                                    jjtc004 = false;
                                  } else {
                                    jjtree.popNode();
                                  }
                                  if (jjte004 instanceof RuntimeException) {
                                    throw (RuntimeException)jjte004;
                                  }
                                  if (jjte004 instanceof ParseException) {
                                    throw (ParseException)jjte004;
                                  }
                                  throw (Error)jjte004;
                                } finally {
                                  if (jjtc004) {
                                    jjtree.closeNodeScope(jjtn004, true);
                                  }
                                }
/*@egen*/ 	           | 	< KW_SELECT >/*@bgen(jjtree) Select */
                      {
                        ASTSelect jjtn005 = new ASTSelect(this, JJTSELECT);
                        boolean jjtc005 = true;
                        jjtree.openNodeScope(jjtn005);
                      }
                      try {
/*@egen*/ opBool()/*@bgen(jjtree)*/
                      } catch (Throwable jjte005) {
                        if (jjtc005) {
                          jjtree.clearNodeScope(jjtn005);
                          jjtc005 = false;
                        } else {
                          jjtree.popNode();
                        }
                        if (jjte005 instanceof RuntimeException) {
                          throw (RuntimeException)jjte005;
                        }
                        if (jjte005 instanceof ParseException) {
                          throw (ParseException)jjte005;
                        }
                        throw (Error)jjte005;
                      } finally {
                        if (jjtc005) {
                          jjtree.closeNodeScope(jjtn005, true);
                        }
                      }
/*@egen*/ 									       | 	opBool()}  /** * boolean ops has the lowest precedence, * ATTENTION: Formula language is the only language I know, where AND and OR has the same precedence! */private void opBool() :{ }{  opCmp() (/*@bgen(jjtree) #Operator( 2) */
    {
      ASTOperator jjtn001 = new ASTOperator(this, JJTOPERATOR);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
    }
    try {
/*@egen*/    (    		< BoolAnd > opCmp()/*@bgen(jjtree)*/
                                    {
                                      jjtree.closeNodeScope(jjtn001,  2);
                                      jjtc001 = false;
                                    }
/*@egen*/ {jjtn001.setFunction("&");	}    	| 	< BoolOr >  opCmp()/*@bgen(jjtree)*/
                                    {
                                      jjtree.closeNodeScope(jjtn001,  2);
                                      jjtc001 = false;
                                    }
/*@egen*/ {jjtn001.setFunction("|");	}  	  	)/*@bgen(jjtree)*/
    } catch (Throwable jjte001) {
      if (jjtc001) {
        jjtree.clearNodeScope(jjtn001);
        jjtc001 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte001 instanceof RuntimeException) {
        throw (RuntimeException)jjte001;
      }
      if (jjte001 instanceof ParseException) {
        throw (ParseException)jjte001;
      }
      throw (Error)jjte001;
    } finally {
      if (jjtc001) {
        jjtree.closeNodeScope(jjtn001,  2);
      }
    }
/*@egen*/               )*}/** * before boolean, all compares are evaluated */private void opCmp()  :{ }{  opAdd()  (/*@bgen(jjtree) #Operator( 2) */
    {
      ASTOperator jjtn001 = new ASTOperator(this, JJTOPERATOR);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
    }
    try {
/*@egen*/    (     		< CmpEqual > 	opAdd()/*@bgen(jjtree)*/
                                        {
                                          jjtree.closeNodeScope(jjtn001,  2);
                                          jjtc001 = false;
                                        }
/*@egen*/ {jjtn001.setFunction("=")		;}    	| 	< CmpEqualP > 	opAdd()/*@bgen(jjtree)*/
                                        {
                                          jjtree.closeNodeScope(jjtn001,  2);
                                          jjtc001 = false;
                                        }
/*@egen*/ {jjtn001.setFunction("*=")		;}     	| 	< CmpNE > 		opAdd()/*@bgen(jjtree)*/
                                                {
                                                  jjtree.closeNodeScope(jjtn001,  2);
                                                  jjtc001 = false;
                                                }
/*@egen*/ {jjtn001.setFunction("<>")		;}     	| 	< CmpNEP > 		opAdd()/*@bgen(jjtree)*/
                                                {
                                                  jjtree.closeNodeScope(jjtn001,  2);
                                                  jjtc001 = false;
                                                }
/*@egen*/ {jjtn001.setFunction("*<>")		;}     	| 	< CmpLT > 		opAdd()/*@bgen(jjtree)*/
                                                {
                                                  jjtree.closeNodeScope(jjtn001,  2);
                                                  jjtc001 = false;
                                                }
/*@egen*/ {jjtn001.setFunction("<")		;}     	| 	< CmpLTP > 		opAdd()/*@bgen(jjtree)*/
                                                {
                                                  jjtree.closeNodeScope(jjtn001,  2);
                                                  jjtc001 = false;
                                                }
/*@egen*/ {jjtn001.setFunction("*<")		;}    	| 	< CmpGT > 		opAdd()/*@bgen(jjtree)*/
                                                {
                                                  jjtree.closeNodeScope(jjtn001,  2);
                                                  jjtc001 = false;
                                                }
/*@egen*/ {jjtn001.setFunction(">")		;}     	| 	< CmpGTP > 		opAdd()/*@bgen(jjtree)*/
                                                {
                                                  jjtree.closeNodeScope(jjtn001,  2);
                                                  jjtc001 = false;
                                                }
/*@egen*/ {jjtn001.setFunction("*>")		;}     	| 	< CmpLTE > 		opAdd()/*@bgen(jjtree)*/
                                                {
                                                  jjtree.closeNodeScope(jjtn001,  2);
                                                  jjtc001 = false;
                                                }
/*@egen*/ {jjtn001.setFunction("<=")		;}     	| 	< CmpLTEP > 	opAdd()/*@bgen(jjtree)*/
                                        {
                                          jjtree.closeNodeScope(jjtn001,  2);
                                          jjtc001 = false;
                                        }
/*@egen*/ {jjtn001.setFunction("*<=")		;}     	| 	< CmpGTE > 		opAdd()/*@bgen(jjtree)*/
                                                {
                                                  jjtree.closeNodeScope(jjtn001,  2);
                                                  jjtc001 = false;
                                                }
/*@egen*/ {jjtn001.setFunction(">=")		;}     	| 	< CmpGTEP > 	opAdd()/*@bgen(jjtree)*/
                                        {
                                          jjtree.closeNodeScope(jjtn001,  2);
                                          jjtc001 = false;
                                        }
/*@egen*/ {jjtn001.setFunction("*>=")		;}    )/*@bgen(jjtree)*/
    } catch (Throwable jjte001) {
      if (jjtc001) {
        jjtree.clearNodeScope(jjtn001);
        jjtc001 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte001 instanceof RuntimeException) {
        throw (RuntimeException)jjte001;
      }
      if (jjte001 instanceof ParseException) {
        throw (ParseException)jjte001;
      }
      throw (Error)jjte001;
    } finally {
      if (jjtc001) {
        jjtree.closeNodeScope(jjtn001,  2);
      }
    }
/*@egen*/             )*}/** * next precedence are all add/subtract operations */private void opAdd() :{ }{    opMult()  (LOOKAHEAD(2)/*@bgen(jjtree) #Operator( 2) */
                          {
                            ASTOperator jjtn001 = new ASTOperator(this, JJTOPERATOR);
                            boolean jjtc001 = true;
                            jjtree.openNodeScope(jjtn001);
                          }
                          try {
/*@egen*/ ( // lookahead 2 is required, to determine if it is a sign 			< OpPlus >	 	opMult()/*@bgen(jjtree)*/
                                                         {
                                                           jjtree.closeNodeScope(jjtn001,  2);
                                                           jjtc001 = false;
                                                         }
/*@egen*/ {jjtn001.setFunction("+")	;} 		| 	< OpPlusP >		opMult()/*@bgen(jjtree)*/
                                                         {
                                                           jjtree.closeNodeScope(jjtn001,  2);
                                                           jjtc001 = false;
                                                         }
/*@egen*/ {jjtn001.setFunction("*+")	;} 		| 	< OpMinus > 	opMult()/*@bgen(jjtree)*/
                                                 {
                                                   jjtree.closeNodeScope(jjtn001,  2);
                                                   jjtc001 = false;
                                                 }
/*@egen*/ {jjtn001.setFunction("-")	;} 		| 	< OpMinusP > 	opMult()/*@bgen(jjtree)*/
                                                 {
                                                   jjtree.closeNodeScope(jjtn001,  2);
                                                   jjtc001 = false;
                                                 }
/*@egen*/ {jjtn001.setFunction("*-")	;} 	)/*@bgen(jjtree)*/
                          } catch (Throwable jjte001) {
                            if (jjtc001) {
                              jjtree.clearNodeScope(jjtn001);
                              jjtc001 = false;
                            } else {
                              jjtree.popNode();
                            }
                            if (jjte001 instanceof RuntimeException) {
                              throw (RuntimeException)jjte001;
                            }
                            if (jjte001 instanceof ParseException) {
                              throw (ParseException)jjte001;
                            }
                            throw (Error)jjte001;
                          } finally {
                            if (jjtc001) {
                              jjtree.closeNodeScope(jjtn001,  2);
                            }
                          }
/*@egen*/               )*}/** * highest precedence of operations is multiplication. This is done with a unary list */private void opMult()  :{ }{  valueList()  (/*@bgen(jjtree) #Operator( 2) */
    {
      ASTOperator jjtn001 = new ASTOperator(this, JJTOPERATOR);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
    }
    try {
/*@egen*/    (      		< OpMul > 	valueList()/*@bgen(jjtree)*/
                                             {
                                               jjtree.closeNodeScope(jjtn001,  2);
                                               jjtc001 = false;
                                             }
/*@egen*/  {jjtn001.setFunction("*")	;}     	|	< OpMulP > 	valueList()/*@bgen(jjtree)*/
                                             {
                                               jjtree.closeNodeScope(jjtn001,  2);
                                               jjtc001 = false;
                                             }
/*@egen*/  {jjtn001.setFunction("**")	;}      	| 	< OpDiv > 	valueList()/*@bgen(jjtree)*/
                                             {
                                               jjtree.closeNodeScope(jjtn001,  2);
                                               jjtc001 = false;
                                             }
/*@egen*/  {jjtn001.setFunction("/")	;}      	| 	< OpDivP > 	valueList()/*@bgen(jjtree)*/
                                             {
                                               jjtree.closeNodeScope(jjtn001,  2);
                                               jjtc001 = false;
                                             }
/*@egen*/  {jjtn001.setFunction("*/")	;}	)/*@bgen(jjtree)*/
    } catch (Throwable jjte001) {
      if (jjtc001) {
        jjtree.clearNodeScope(jjtn001);
        jjtc001 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte001 instanceof RuntimeException) {
        throw (RuntimeException)jjte001;
      }
      if (jjte001 instanceof ParseException) {
        throw (ParseException)jjte001;
      }
      throw (Error)jjte001;
    } finally {
      if (jjtc001) {
        jjtree.closeNodeScope(jjtn001,  2);
      }
    }
/*@egen*/              ) *}/** * one ore more values * for saving mem, unaries are wrapped only in a valueList, if there are more than once */private void valueList() :{}{/*@bgen(jjtree) #ValueList(> 1) */
        {
          ASTValueList jjtn001 = new ASTValueList(this, JJTVALUELIST);
          boolean jjtc001 = true;
          jjtree.openNodeScope(jjtn001);
        }
        try {
/*@egen*/	(subscript() (< ListConcat > subscript())* )/*@bgen(jjtree)*/
        } catch (Throwable jjte001) {
          if (jjtc001) {
            jjtree.clearNodeScope(jjtn001);
            jjtc001 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte001 instanceof RuntimeException) {
            throw (RuntimeException)jjte001;
          }
          if (jjte001 instanceof ParseException) {
            throw (ParseException)jjte001;
          }
          throw (Error)jjte001;
        } finally {
          if (jjtc001) {
            jjtree.closeNodeScope(jjtn001, jjtree.nodeArity() > 1);
          }
        }
/*@egen*/                 }private void subscript() :{}{/*@bgen(jjtree) #Subscript(> 1) */
        {
          ASTSubscript jjtn001 = new ASTSubscript(this, JJTSUBSCRIPT);
          boolean jjtc001 = true;
          jjtree.openNodeScope(jjtn001);
        }
        try {
/*@egen*/  	(unary()  (< OSubscript > statement() < CSubscript >)*)/*@bgen(jjtree)*/
        } catch (Throwable jjte001) {
          if (jjtc001) {
            jjtree.clearNodeScope(jjtn001);
            jjtc001 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte001 instanceof RuntimeException) {
            throw (RuntimeException)jjte001;
          }
          if (jjte001 instanceof ParseException) {
            throw (ParseException)jjte001;
          }
          throw (Error)jjte001;
        } finally {
          if (jjtc001) {
            jjtree.closeNodeScope(jjtn001, jjtree.nodeArity() > 1);
          }
        }
/*@egen*/               }private void unary() :{}{ 	< OpPlus > unary() | 	< OpMinus > unary()/*@bgen(jjtree) #Operator( 1) */
                            {
                              ASTOperator jjtn001 = new ASTOperator(this, JJTOPERATOR);
                              boolean jjtc001 = true;
                              jjtree.openNodeScope(jjtn001);
                            }
                            try {
/*@egen*//*@bgen(jjtree)*/
                            {
                              jjtree.closeNodeScope(jjtn001,  1);
                              jjtc001 = false;
                            }
/*@egen*/ {jjtn001.setFunction(" -")	;}/*@bgen(jjtree)*/
                            } finally {
                              if (jjtc001) {
                                jjtree.closeNodeScope(jjtn001,  1);
                              }
                            }
/*@egen*/             | 	< BoolNot > unary()/*@bgen(jjtree) #Operator( 1) */
                            {
                              ASTOperator jjtn002 = new ASTOperator(this, JJTOPERATOR);
                              boolean jjtc002 = true;
                              jjtree.openNodeScope(jjtn002);
                            }
                            try {
/*@egen*//*@bgen(jjtree)*/
                            {
                              jjtree.closeNodeScope(jjtn002,  1);
                              jjtc002 = false;
                            }
/*@egen*/ {jjtn002.setFunction(" !")		;}/*@bgen(jjtree)*/
                            } finally {
                              if (jjtc002) {
                                jjtree.closeNodeScope(jjtn002,  1);
                              }
                            }
/*@egen*/             // All control flow functions| < At_do >/*@bgen(jjtree) AtDo */
                        {
                          ASTAtDo jjtn003 = new ASTAtDo(this, JJTATDO);
                          boolean jjtc003 = true;
                          jjtree.openNodeScope(jjtn003);
                        }
                        try {
/*@egen*/ 		(< OParen >  statement() ( < EOS > statement() )*  < CParen >)/*@bgen(jjtree)*/
                        } catch (Throwable jjte003) {
                          if (jjtc003) {
                            jjtree.clearNodeScope(jjtn003);
                            jjtc003 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte003 instanceof RuntimeException) {
                            throw (RuntimeException)jjte003;
                          }
                          if (jjte003 instanceof ParseException) {
                            throw (ParseException)jjte003;
                          }
                          throw (Error)jjte003;
                        } finally {
                          if (jjtc003) {
                            jjtree.closeNodeScope(jjtn003, true);
                          }
                        }
/*@egen*/      | < At_doWhile >/*@bgen(jjtree) AtDoWhile */
                        {
                          ASTAtDoWhile jjtn004 = new ASTAtDoWhile(this, JJTATDOWHILE);
                          boolean jjtc004 = true;
                          jjtree.openNodeScope(jjtn004);
                        }
                        try {
/*@egen*/ 	(< OParen >  statement() ( < EOS > statement() )*  < CParen >)/*@bgen(jjtree)*/
                        } catch (Throwable jjte004) {
                          if (jjtc004) {
                            jjtree.clearNodeScope(jjtn004);
                            jjtc004 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte004 instanceof RuntimeException) {
                            throw (RuntimeException)jjte004;
                          }
                          if (jjte004 instanceof ParseException) {
                            throw (ParseException)jjte004;
                          }
                          throw (Error)jjte004;
                        } finally {
                          if (jjtc004) {
                            jjtree.closeNodeScope(jjtn004, true);
                          }
                        }
/*@egen*/           | < At_for >/*@bgen(jjtree) AtFor */
                        {
                          ASTAtFor jjtn005 = new ASTAtFor(this, JJTATFOR);
                          boolean jjtc005 = true;
                          jjtree.openNodeScope(jjtn005);
                        }
                        try {
/*@egen*/		(< OParen >  	statement()	// initialize						< EOS >		statement()	// condition						< EOS >		statement() 	// increment						( < EOS > 	statement() )*	// statements					 < CParen >)/*@bgen(jjtree)*/
                        } catch (Throwable jjte005) {
                          if (jjtc005) {
                            jjtree.clearNodeScope(jjtn005);
                            jjtc005 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte005 instanceof RuntimeException) {
                            throw (RuntimeException)jjte005;
                          }
                          if (jjte005 instanceof ParseException) {
                            throw (ParseException)jjte005;
                          }
                          throw (Error)jjte005;
                        } finally {
                          if (jjtc005) {
                            jjtree.closeNodeScope(jjtn005, true);
                          }
                        }
/*@egen*/       | (< At_if > | < At_v2if > )/*@bgen(jjtree) AtIf */
                                        {
                                          ASTAtIf jjtn006 = new ASTAtIf(this, JJTATIF);
                                          boolean jjtc006 = true;
                                          jjtree.openNodeScope(jjtn006);
                                        }
                                        try {
/*@egen*/					(< OParen >  	statement()	// if						( < EOS > 	statement() < EOS > statement())+	// the elese(if)					 < CParen >)/*@bgen(jjtree)*/
                                        } catch (Throwable jjte006) {
                                          if (jjtc006) {
                                            jjtree.clearNodeScope(jjtn006);
                                            jjtc006 = false;
                                          } else {
                                            jjtree.popNode();
                                          }
                                          if (jjte006 instanceof RuntimeException) {
                                            throw (RuntimeException)jjte006;
                                          }
                                          if (jjte006 instanceof ParseException) {
                                            throw (ParseException)jjte006;
                                          }
                                          throw (Error)jjte006;
                                        } finally {
                                          if (jjtc006) {
                                            jjtree.closeNodeScope(jjtn006, true);
                                          }
                                        }
/*@egen*/      					 | < At_iferror >/*@bgen(jjtree) AtIfError */
                        {
                          ASTAtIfError jjtn007 = new ASTAtIfError(this, JJTATIFERROR);
                          boolean jjtc007 = true;
                          jjtree.openNodeScope(jjtn007);
                        }
                        try {
/*@egen*/	(< OParen >  	statement() (< EOS > statement())? < CParen >)/*@bgen(jjtree)*/
                        } catch (Throwable jjte007) {
                          if (jjtc007) {
                            jjtree.clearNodeScope(jjtn007);
                            jjtc007 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte007 instanceof RuntimeException) {
                            throw (RuntimeException)jjte007;
                          }
                          if (jjte007 instanceof ParseException) {
                            throw (ParseException)jjte007;
                          }
                          throw (Error)jjte007;
                        } finally {
                          if (jjtc007) {
                            jjtree.closeNodeScope(jjtn007, true);
                          }
                        }
/*@egen*/           | < At_transform >/*@bgen(jjtree) AtTranform */
                        {
                          ASTAtTranform jjtn008 = new ASTAtTranform(this, JJTATTRANFORM);
                          boolean jjtc008 = true;
                          jjtree.openNodeScope(jjtn008);
                        }
                        try {
/*@egen*/	(< OParen >  	statement()	// list						< EOS >		statement()	// varName						< EOS >		statement() 	// formula					 < CParen >)/*@bgen(jjtree)*/
                        } catch (Throwable jjte008) {
                          if (jjtc008) {
                            jjtree.clearNodeScope(jjtn008);
                            jjtc008 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte008 instanceof RuntimeException) {
                            throw (RuntimeException)jjte008;
                          }
                          if (jjte008 instanceof ParseException) {
                            throw (ParseException)jjte008;
                          }
                          throw (Error)jjte008;
                        } finally {
                          if (jjtc008) {
                            jjtree.closeNodeScope(jjtn008, true);
                          }
                        }
/*@egen*/            	 | < At_other > formula() | atom()}private void formula()           :{/*@bgen(jjtree) Function */
  ASTFunction jjtn000 = new ASTFunction(this, JJTFUNCTION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}{/*@bgen(jjtree) Function */
  try {
/*@egen*/  { jjtn000.setFunction(getToken(0).image); }  // Optional parameters.   ( LOOKAHEAD(2)  	< OParen >    	  statement() ( < EOS > statement() )*    < CParen >  )?/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/   }private void atom() :{}{   value()| < OParen > statement() <CParen >}/*private void setDefault() #SetDefault :{    Token t;}{	t = <Identifier >	< Assign > opBool()	{ jjtThis.value = t.image; }}private void setEnvironment() #SetEnvironment :{    Token t;}{	t = <Identifier >	< Assign > opBool()	{ jjtThis.value = t.image; }}private void setField() #SetField :{    Token t;}{	t = <Identifier >	< Assign > opBool()	{ jjtThis.value = t.image; }}private void setVariable() #SetVariable :{}{	opBool()	{ jjtThis.value =  getToken(0).image; }}*/private void value()  :{  Token t;}{  	t = < Date_or_KW >/*@bgen(jjtree) ValueDateOrKW */
        {
          ASTValueDateOrKW jjtn001 = new ASTValueDateOrKW(this, JJTVALUEDATEORKW);
          boolean jjtc001 = true;
          jjtree.openNodeScope(jjtn001);
        }
        try {
/*@egen*//*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn001, true);
          jjtc001 = false;
        }
/*@egen*/  	{ jjtn001.init(t.image); }/*@bgen(jjtree)*/
        } finally {
          if (jjtc001) {
            jjtree.closeNodeScope(jjtn001, true);
          }
        }
/*@egen*/               |	t = < String1 >/*@bgen(jjtree) ValueString */
        {
          ASTValueString jjtn002 = new ASTValueString(this, JJTVALUESTRING);
          boolean jjtc002 = true;
          jjtree.openNodeScope(jjtn002);
        }
        try {
/*@egen*//*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn002, true);
          jjtc002 = false;
        }
/*@egen*/  	{ jjtn002.parseString(t.image, '"'); }/*@bgen(jjtree)*/
        } finally {
          if (jjtc002) {
            jjtree.closeNodeScope(jjtn002, true);
          }
        }
/*@egen*/             |	t = < String2 >/*@bgen(jjtree) ValueString */
        {
          ASTValueString jjtn003 = new ASTValueString(this, JJTVALUESTRING);
          boolean jjtc003 = true;
          jjtree.openNodeScope(jjtn003);
        }
        try {
/*@egen*//*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn003, true);
          jjtc003 = false;
        }
/*@egen*/  	{ jjtn003.parseString(t.image, '{' ); }/*@bgen(jjtree)*/
        } finally {
          if (jjtc003) {
            jjtree.closeNodeScope(jjtn003, true);
          }
        }
/*@egen*/             |	t = < NumDoubleUS >/*@bgen(jjtree) ValueDouble */
        {
          ASTValueDouble jjtn004 = new ASTValueDouble(this, JJTVALUEDOUBLE);
          boolean jjtc004 = true;
          jjtree.openNodeScope(jjtn004);
        }
        try {
/*@egen*//*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn004, true);
          jjtc004 = false;
        }
/*@egen*/  	{ jjtn004.parseDouble(t.image,'.'); }/*@bgen(jjtree)*/
        } finally {
          if (jjtc004) {
            jjtree.closeNodeScope(jjtn004, true);
          }
        }
/*@egen*/             |	t = < NumDoubleDE >/*@bgen(jjtree) ValueDouble */
        {
          ASTValueDouble jjtn005 = new ASTValueDouble(this, JJTVALUEDOUBLE);
          boolean jjtc005 = true;
          jjtree.openNodeScope(jjtn005);
        }
        try {
/*@egen*//*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn005, true);
          jjtc005 = false;
        }
/*@egen*/  	{ jjtn005.parseDouble(t.image,','); }/*@bgen(jjtree)*/
        } finally {
          if (jjtc005) {
            jjtree.closeNodeScope(jjtn005, true);
          }
        }
/*@egen*/             |	t = < NumInteger >/*@bgen(jjtree) ValueLong */
        {
          ASTValueLong jjtn006 = new ASTValueLong(this, JJTVALUELONG);
          boolean jjtc006 = true;
          jjtree.openNodeScope(jjtn006);
        }
        try {
/*@egen*//*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn006, true);
          jjtc006 = false;
        }
/*@egen*/  	{ jjtn006.parseLong(t.image); }/*@bgen(jjtree)*/
        } finally {
          if (jjtc006) {
            jjtree.closeNodeScope(jjtn006, true);
          }
        }
/*@egen*/           |	t = < Identifier >/*@bgen(jjtree) GetVariable */
        {
          ASTGetVariable jjtn007 = new ASTGetVariable(this, JJTGETVARIABLE);
          boolean jjtc007 = true;
          jjtree.openNodeScope(jjtn007);
        }
        try {
/*@egen*//*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn007, true);
          jjtc007 = false;
        }
/*@egen*/  	{ jjtn007.init(t.image); }/*@bgen(jjtree)*/
        } finally {
          if (jjtc007) {
            jjtree.closeNodeScope(jjtn007, true);
          }
        }
/*@egen*/             	}