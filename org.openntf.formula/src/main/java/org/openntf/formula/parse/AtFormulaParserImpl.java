/* Generated By:JJTree&JavaCC: Do not edit this line. AtFormulaParserImpl.java */
/*
 *  Â© Copyright FOCONIS AG, 2014
 * 
 * Licensed under the Apache License, Version 2.0 (the "License"); 
 * you may not use this file except in compliance with the License. 
 * You may obtain a copy of the License at:
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software 
 * distributed under the License is distributed on an "AS IS" BASIS, 
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or 
 * implied. See the License for the specific language governing 
 * permissions and limitations under the License.
 */
package org.openntf.formula.parse;

import org.openntf.formula.FormulaParser;
import org.openntf.formula.ast.ASTAssignment;
import org.openntf.formula.ast.ASTAtConCat;
import org.openntf.formula.ast.ASTAtDo;
import org.openntf.formula.ast.ASTAtDoWhile;
import org.openntf.formula.ast.ASTAtEval;
import org.openntf.formula.ast.ASTAtEvalEx;
import org.openntf.formula.ast.ASTAtFocEval;
import org.openntf.formula.ast.ASTAtFor;
import org.openntf.formula.ast.ASTAtIf;
import org.openntf.formula.ast.ASTAtIfError;
import org.openntf.formula.ast.ASTAtIsAvailable;
import org.openntf.formula.ast.ASTAtIsError;
import org.openntf.formula.ast.ASTAtIsUnavailable;
import org.openntf.formula.ast.ASTAtReturn;
import org.openntf.formula.ast.ASTAtSort;
import org.openntf.formula.ast.ASTAtText;
import org.openntf.formula.ast.ASTAtTransform;
import org.openntf.formula.ast.ASTAtWhile;
import org.openntf.formula.ast.ASTFocNormalText;
import org.openntf.formula.ast.ASTFocParam;
import org.openntf.formula.ast.ASTFunction;
import org.openntf.formula.ast.ASTGetVariable;
import org.openntf.formula.ast.ASTOperator;
import org.openntf.formula.ast.ASTSelect;
import org.openntf.formula.ast.ASTSubscript;
import org.openntf.formula.ast.ASTUserDefinedFunction;
import org.openntf.formula.ast.ASTUserDefinedFunctionDef;
import org.openntf.formula.ast.ASTUserDefinedFunctionParameter;
import org.openntf.formula.ast.ASTUserDefinedFunctionVariable;
import org.openntf.formula.ast.ASTUserDefinedInclude;
import org.openntf.formula.ast.ASTValueDateOrKW;
import org.openntf.formula.ast.ASTValueDouble;
import org.openntf.formula.ast.ASTValueInt;
import org.openntf.formula.ast.ASTValueList;
import org.openntf.formula.ast.ASTValueString;
import org.openntf.formula.ast.AtFormulaParserImplTreeConstants;
import org.openntf.formula.ast.JJTAtFormulaParserImplState;
import org.openntf.formula.ast.SimpleNode;

public class AtFormulaParserImpl extends FormulaParser/*@bgen(jjtree)*/implements AtFormulaParserImplTreeConstants,
AtFormulaParserImplConstants {/*@bgen(jjtree)*/
	protected JJTAtFormulaParserImplState jjtree = new JJTAtFormulaParserImplState();

	@SuppressWarnings("unused")
	@Override
	final public SimpleNode parseFormula() throws ParseException {
		/*@bgen(jjtree) AtDo */
		ASTAtDo jjtn000 = new ASTAtDo(this, JJTATDO);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		try {
			mainStatement();
			label_1: while (true) {
				switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
				case EOS:
					;
					break;
				default:
					jj_la1[0] = jj_gen;
					break label_1;
				}
				jj_consume_token(EOS);
				mainStatement();
			}
			jj_consume_token(0);
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.setVirtual(true);
			{
				if (true)
					return jjtn000;
			}
		} catch (Throwable jjte000) {
			if (jjtc000) {
				jjtree.clearNodeScope(jjtn000);
				jjtc000 = false;
			} else {
				jjtree.popNode();
			}
			if (jjte000 instanceof RuntimeException) {
				{
					if (true)
						throw (RuntimeException) jjte000;
				}
			}
			if (jjte000 instanceof ParseException) {
				{
					if (true)
						throw (ParseException) jjte000;
				}
			}
			{
				if (true)
					throw (Error) jjte000;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final public void mainStatement() throws ParseException {
		label_2: while (true) {
			switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
			case EOS:
				;
				break;
			default:
				jj_la1[1] = jj_gen;
				break label_2;
			}
			jj_consume_token(EOS);
		}
	switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
	case KW_REM:
		jj_consume_token(KW_REM);
		comment();
		break;
	case Date_or_KW:
	case OParen:
	case KW_DEFAULT:
	case KW_ENVIRONMENT:
	case KW_FIELD:
	case KW_SELECT:
	case At_Include:
	case At_Function:
	case At_do:
	case At_doWhile:
	case At_while:
	case At_for:
	case At_if:
	case At_v2if:
	case At_iferror:
	case At_transform:
	case At_sort:
	case At_text:
	case At_eval:
	case At_evalex:
	case At_foceval:
	case At_return:
	case At_iserror:
	case At_isavailable:
	case At_isunavailable:
	case At_other:
	case OpPlus:
	case OpMinus:
	case BoolNot:
	case NumDoubleUS:
	case NumDoubleDE:
	case NumInteger:
	case String1:
	case String2:
	case Identifier:
		statement();
		break;
	default:
		jj_la1[2] = jj_gen;
		jj_consume_token(-1);
		throw new ParseException();
	}
	}

	final private void comment() throws ParseException {
		switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
		case String1:
			jj_consume_token(String1);
			break;
		case String2:
			jj_consume_token(String2);
			break;
		case OParen:
			jj_consume_token(OParen);
			comment();
			jj_consume_token(CParen);
			break;
		default:
			jj_la1[3] = jj_gen;
			jj_consume_token(-1);
			throw new ParseException();
		}
	}

	@SuppressWarnings("unused")
	@Override
	final public SimpleNode parseFocFormula() throws ParseException {
		/*@bgen(jjtree) AtConCat */
		ASTAtConCat jjtn000 = new ASTAtConCat(this, JJTATCONCAT);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		try {
			token_source.SwitchTo(FOCONIS);
			label_3: while (true) {
				switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
				case NORMAL_TEXT:
				case BEGIN_FORMULA:
				case BEGIN_PARAM:
					;
					break;
				default:
					jj_la1[4] = jj_gen;
					break label_3;
				}
				switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
				case NORMAL_TEXT:
					focNormalText();
					break;
				case BEGIN_FORMULA:
					focFormula();
					break;
				case BEGIN_PARAM:
					focParam();
					break;
				default:
					jj_la1[5] = jj_gen;
					jj_consume_token(-1);
					throw new ParseException();
				}
			}
			jj_consume_token(0);
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			{
				if (true)
					return jjtn000;
			}
		} catch (Throwable jjte000) {
			if (jjtc000) {
				jjtree.clearNodeScope(jjtn000);
				jjtc000 = false;
			} else {
				jjtree.popNode();
			}
			if (jjte000 instanceof RuntimeException) {
				{
					if (true)
						throw (RuntimeException) jjte000;
				}
			}
			if (jjte000 instanceof ParseException) {
				{
					if (true)
						throw (ParseException) jjte000;
				}
			}
			{
				if (true)
					throw (Error) jjte000;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
		throw new Error("Missing return statement in function");
	}

	final private void focFormula() throws ParseException {
		jj_consume_token(BEGIN_FORMULA);
		ASTAtDo jjtn001 = new ASTAtDo(this, JJTATDO);
		boolean jjtc001 = true;
		jjtree.openNodeScope(jjtn001);
		try {
			mainStatement();
			label_4: while (true) {
				switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
				case EOS:
					;
					break;
				default:
					jj_la1[6] = jj_gen;
					break label_4;
				}
				jj_consume_token(EOS);
				mainStatement();
			}
			jjtree.closeNodeScope(jjtn001, true);
			jjtc001 = false;
			jjtn001.setVirtual(true);
		} catch (Throwable jjte001) {
			if (jjtc001) {
				jjtree.clearNodeScope(jjtn001);
				jjtc001 = false;
			} else {
				jjtree.popNode();
			}
			if (jjte001 instanceof RuntimeException) {
				{
					if (true)
						throw (RuntimeException) jjte001;
				}
			}
			if (jjte001 instanceof ParseException) {
				{
					if (true)
						throw (ParseException) jjte001;
				}
			}
			{
				if (true)
					throw (Error) jjte001;
			}
		} finally {
			if (jjtc001) {
				jjtree.closeNodeScope(jjtn001, true);
			}
		}
		jj_consume_token(END_FORMULA);
	}

	final private void focParam() throws ParseException {
		/*@bgen(jjtree) FocParam */
		ASTFocParam jjtn000 = new ASTFocParam(this, JJTFOCPARAM);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t;
		try {
			jj_consume_token(BEGIN_PARAM);
			t = jj_consume_token(PARAM_VALUE);
			jj_consume_token(END_PARAM);
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.init(t.image);
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
	}

	final private void focNormalText() throws ParseException {
		/*@bgen(jjtree) FocNormalText */
		ASTFocNormalText jjtn000 = new ASTFocNormalText(this, JJTFOCNORMALTEXT);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t;
		try {
			t = jj_consume_token(NORMAL_TEXT);
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.init(t.image);
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
	}

	final private void statement() throws ParseException {
		Token t;
		switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
		case At_Include:
			jj_consume_token(At_Include);
			ASTUserDefinedInclude jjtn001 = new ASTUserDefinedInclude(this, JJTUSERDEFINEDINCLUDE);
			boolean jjtc001 = true;
			jjtree.openNodeScope(jjtn001);
			try {
				opBool();
				jjtree.closeNodeScope(jjtn001, true);
				jjtc001 = false;
				jjtn001.init();
			} catch (Throwable jjte001) {
				if (jjtc001) {
					jjtree.clearNodeScope(jjtn001);
					jjtc001 = false;
				} else {
					jjtree.popNode();
				}
				if (jjte001 instanceof RuntimeException) {
					{
						if (true)
							throw (RuntimeException) jjte001;
					}
				}
				if (jjte001 instanceof ParseException) {
					{
						if (true)
							throw (ParseException) jjte001;
					}
				}
				{
					if (true)
						throw (Error) jjte001;
				}
			} finally {
				if (jjtc001) {
					jjtree.closeNodeScope(jjtn001, true);
				}
			}
			break;
		case At_Function:
			jj_consume_token(At_Function);
			ASTUserDefinedFunction jjtn002 = new ASTUserDefinedFunction(this, JJTUSERDEFINEDFUNCTION);
			boolean jjtc002 = true;
			jjtree.openNodeScope(jjtn002);
			try {
				jj_consume_token(OParen);
				exFuncDef();
				label_5: while (true) {
					switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
					case EOS:
						;
						break;
					default:
						jj_la1[7] = jj_gen;
						break label_5;
					}
					jj_consume_token(EOS);
					exVar();
				}
				jj_consume_token(CParen);
				switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
				case Assign:
					jj_consume_token(Assign);
					opBool();
					break;
				default:
					jj_la1[8] = jj_gen;
					;
				}
				jjtree.closeNodeScope(jjtn002, true);
				jjtc002 = false;
				jjtn002.init();
			} catch (Throwable jjte002) {
				if (jjtc002) {
					jjtree.clearNodeScope(jjtn002);
					jjtc002 = false;
				} else {
					jjtree.popNode();
				}
				if (jjte002 instanceof RuntimeException) {
					{
						if (true)
							throw (RuntimeException) jjte002;
					}
				}
				if (jjte002 instanceof ParseException) {
					{
						if (true)
							throw (ParseException) jjte002;
					}
				}
				{
					if (true)
						throw (Error) jjte002;
				}
			} finally {
				if (jjtc002) {
					jjtree.closeNodeScope(jjtn002, true);
				}
			}
			break;
		case KW_FIELD:
			jj_consume_token(KW_FIELD);
			ASTAssignment jjtn003 = new ASTAssignment(this, JJTASSIGNMENT);
			boolean jjtc003 = true;
			jjtree.openNodeScope(jjtn003);
			try {
				t = jj_consume_token(Identifier);
				jj_consume_token(Assign);
				jjtn003.init(t.image, ASTAssignment.FIELD);
				opBool();
			} catch (Throwable jjte003) {
				if (jjtc003) {
					jjtree.clearNodeScope(jjtn003);
					jjtc003 = false;
				} else {
					jjtree.popNode();
				}
				if (jjte003 instanceof RuntimeException) {
					{
						if (true)
							throw (RuntimeException) jjte003;
					}
				}
				if (jjte003 instanceof ParseException) {
					{
						if (true)
							throw (ParseException) jjte003;
					}
				}
				{
					if (true)
						throw (Error) jjte003;
				}
			} finally {
				if (jjtc003) {
					jjtree.closeNodeScope(jjtn003, true);
				}
			}
			break;
		default:
			jj_la1[9] = jj_gen;
			if (jj_2_1(2)) {
				ASTAssignment jjtn004 = new ASTAssignment(this, JJTASSIGNMENT);
				boolean jjtc004 = true;
				jjtree.openNodeScope(jjtn004);
				try {
					t = jj_consume_token(Identifier);
					jj_consume_token(Assign);
					jjtn004.init(t.image, ASTAssignment.VAR);
					opBool();
				} catch (Throwable jjte004) {
					if (jjtc004) {
						jjtree.clearNodeScope(jjtn004);
						jjtc004 = false;
					} else {
						jjtree.popNode();
					}
					if (jjte004 instanceof RuntimeException) {
						{
							if (true)
								throw (RuntimeException) jjte004;
						}
					}
					if (jjte004 instanceof ParseException) {
						{
							if (true)
								throw (ParseException) jjte004;
						}
					}
					{
						if (true)
							throw (Error) jjte004;
					}
				} finally {
					if (jjtc004) {
						jjtree.closeNodeScope(jjtn004, true);
					}
				}
			} else {
				switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
				case KW_ENVIRONMENT:
					jj_consume_token(KW_ENVIRONMENT);
					ASTAssignment jjtn005 = new ASTAssignment(this, JJTASSIGNMENT);
					boolean jjtc005 = true;
					jjtree.openNodeScope(jjtn005);
					try {
						t = jj_consume_token(Identifier);
						jj_consume_token(Assign);
						jjtn005.init(t.image, ASTAssignment.ENV);
						opBool();
					} catch (Throwable jjte005) {
						if (jjtc005) {
							jjtree.clearNodeScope(jjtn005);
							jjtc005 = false;
						} else {
							jjtree.popNode();
						}
						if (jjte005 instanceof RuntimeException) {
							{
								if (true)
									throw (RuntimeException) jjte005;
							}
						}
						if (jjte005 instanceof ParseException) {
							{
								if (true)
									throw (ParseException) jjte005;
							}
						}
						{
							if (true)
								throw (Error) jjte005;
						}
					} finally {
						if (jjtc005) {
							jjtree.closeNodeScope(jjtn005, true);
						}
					}
					break;
				case KW_DEFAULT:
					jj_consume_token(KW_DEFAULT);
					ASTAssignment jjtn006 = new ASTAssignment(this, JJTASSIGNMENT);
					boolean jjtc006 = true;
					jjtree.openNodeScope(jjtn006);
					try {
						t = jj_consume_token(Identifier);
						jj_consume_token(Assign);
						jjtn006.init(t.image, ASTAssignment.DEFAULT);
						opBool();
					} catch (Throwable jjte006) {
						if (jjtc006) {
							jjtree.clearNodeScope(jjtn006);
							jjtc006 = false;
						} else {
							jjtree.popNode();
						}
						if (jjte006 instanceof RuntimeException) {
							{
								if (true)
									throw (RuntimeException) jjte006;
							}
						}
						if (jjte006 instanceof ParseException) {
							{
								if (true)
									throw (ParseException) jjte006;
							}
						}
						{
							if (true)
								throw (Error) jjte006;
						}
					} finally {
						if (jjtc006) {
							jjtree.closeNodeScope(jjtn006, true);
						}
					}
					break;
				case KW_SELECT:
					jj_consume_token(KW_SELECT);
					ASTSelect jjtn007 = new ASTSelect(this, JJTSELECT);
					boolean jjtc007 = true;
					jjtree.openNodeScope(jjtn007);
					try {
						opBool();
					} catch (Throwable jjte007) {
						if (jjtc007) {
							jjtree.clearNodeScope(jjtn007);
							jjtc007 = false;
						} else {
							jjtree.popNode();
						}
						if (jjte007 instanceof RuntimeException) {
							{
								if (true)
									throw (RuntimeException) jjte007;
							}
						}
						if (jjte007 instanceof ParseException) {
							{
								if (true)
									throw (ParseException) jjte007;
							}
						}
						{
							if (true)
								throw (Error) jjte007;
						}
					} finally {
						if (jjtc007) {
							jjtree.closeNodeScope(jjtn007, true);
						}
					}
					break;
				case Date_or_KW:
				case OParen:
				case At_do:
				case At_doWhile:
				case At_while:
				case At_for:
				case At_if:
				case At_v2if:
				case At_iferror:
				case At_transform:
				case At_sort:
				case At_text:
				case At_eval:
				case At_evalex:
				case At_foceval:
				case At_return:
				case At_iserror:
				case At_isavailable:
				case At_isunavailable:
				case At_other:
				case OpPlus:
				case OpMinus:
				case BoolNot:
				case NumDoubleUS:
				case NumDoubleDE:
				case NumInteger:
				case String1:
				case String2:
				case Identifier:
					opBool();
					break;
				default:
					jj_la1[10] = jj_gen;
					jj_consume_token(-1);
					throw new ParseException();
				}
			}
		}
	}

	final private void exFuncDef() throws ParseException {
		/*@bgen(jjtree) UserDefinedFunctionDef */
		ASTUserDefinedFunctionDef jjtn000 = new ASTUserDefinedFunctionDef(this, JJTUSERDEFINEDFUNCTIONDEF);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t;
		try {
			// matches to @myfunc(a:="x";b:="y")
			t = jj_consume_token(At_other);
			switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
			case OParen:
				jj_consume_token(OParen);
				exParam();
				label_6: while (true) {
					switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
					case EOS:
						;
						break;
					default:
						jj_la1[11] = jj_gen;
						break label_6;
					}
					jj_consume_token(EOS);
					exParam();
				}
				jj_consume_token(CParen);
				break;
			default:
				jj_la1[12] = jj_gen;
				;
			}
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.init(t.image);
		} catch (Throwable jjte000) {
			if (jjtc000) {
				jjtree.clearNodeScope(jjtn000);
				jjtc000 = false;
			} else {
				jjtree.popNode();
			}
			if (jjte000 instanceof RuntimeException) {
				{
					if (true)
						throw (RuntimeException) jjte000;
				}
			}
			if (jjte000 instanceof ParseException) {
				{
					if (true)
						throw (ParseException) jjte000;
				}
			}
			{
				if (true)
					throw (Error) jjte000;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
	}

	final private void exParam() throws ParseException {
		/*@bgen(jjtree) UserDefinedFunctionParameter */
		ASTUserDefinedFunctionParameter jjtn000 = new ASTUserDefinedFunctionParameter(this, JJTUSERDEFINEDFUNCTIONPARAMETER);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t;
		try {
			if (jj_2_2(2)) {
				t = jj_consume_token(Identifier);
				jj_consume_token(Assign);
				opBool();
			} else {
				switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
				case Identifier:
					t = jj_consume_token(Identifier);
					break;
				default:
					jj_la1[13] = jj_gen;
					jj_consume_token(-1);
					throw new ParseException();
				}
			}
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.init(t.image);
		} catch (Throwable jjte000) {
			if (jjtc000) {
				jjtree.clearNodeScope(jjtn000);
				jjtc000 = false;
			} else {
				jjtree.popNode();
			}
			if (jjte000 instanceof RuntimeException) {
				{
					if (true)
						throw (RuntimeException) jjte000;
				}
			}
			if (jjte000 instanceof ParseException) {
				{
					if (true)
						throw (ParseException) jjte000;
				}
			}
			{
				if (true)
					throw (Error) jjte000;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
	}

	final private void exVar() throws ParseException {
		/*@bgen(jjtree) UserDefinedFunctionVariable */
		ASTUserDefinedFunctionVariable jjtn000 = new ASTUserDefinedFunctionVariable(this, JJTUSERDEFINEDFUNCTIONVARIABLE);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t;
		try {
			if (jj_2_3(2)) {
				t = jj_consume_token(Identifier);
				jj_consume_token(Assign);
				opBool();
			} else {
				switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
				case Identifier:
					t = jj_consume_token(Identifier);
					break;
				default:
					jj_la1[14] = jj_gen;
					jj_consume_token(-1);
					throw new ParseException();
				}
			}
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.init(t.image);
		} catch (Throwable jjte000) {
			if (jjtc000) {
				jjtree.clearNodeScope(jjtn000);
				jjtc000 = false;
			} else {
				jjtree.popNode();
			}
			if (jjte000 instanceof RuntimeException) {
				{
					if (true)
						throw (RuntimeException) jjte000;
				}
			}
			if (jjte000 instanceof ParseException) {
				{
					if (true)
						throw (ParseException) jjte000;
				}
			}
			{
				if (true)
					throw (Error) jjte000;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
	}

	final private void opBool() throws ParseException {
		opNot();
		label_7: while (true) {
			switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
			case BoolAnd:
			case BoolOr:
				;
				break;
			default:
				jj_la1[15] = jj_gen;
				break label_7;
			}
			ASTOperator jjtn001 = new ASTOperator(this, JJTOPERATOR);
			boolean jjtc001 = true;
			jjtree.openNodeScope(jjtn001);
			try {
				switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
				case BoolAnd:
					jj_consume_token(BoolAnd);
					opNot();
					jjtree.closeNodeScope(jjtn001, 2);
					jjtc001 = false;
					jjtn001.init("&");
					break;
				case BoolOr:
					jj_consume_token(BoolOr);
					opNot();
					jjtree.closeNodeScope(jjtn001, 2);
					jjtc001 = false;
					jjtn001.init("|");
					break;
				default:
					jj_la1[16] = jj_gen;
					jj_consume_token(-1);
					throw new ParseException();
				}
			} catch (Throwable jjte001) {
				if (jjtc001) {
					jjtree.clearNodeScope(jjtn001);
					jjtc001 = false;
				} else {
					jjtree.popNode();
				}
				if (jjte001 instanceof RuntimeException) {
					{
						if (true)
							throw (RuntimeException) jjte001;
					}
				}
				if (jjte001 instanceof ParseException) {
					{
						if (true)
							throw (ParseException) jjte001;
					}
				}
				{
					if (true)
						throw (Error) jjte001;
				}
			} finally {
				if (jjtc001) {
					jjtree.closeNodeScope(jjtn001, 2);
				}
			}
		}
	}

	final private void opNot() throws ParseException {
		switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
		case BoolNot:
			opHasNot();
			break;
		case Date_or_KW:
		case OParen:
		case At_do:
		case At_doWhile:
		case At_while:
		case At_for:
		case At_if:
		case At_v2if:
		case At_iferror:
		case At_transform:
		case At_sort:
		case At_text:
		case At_eval:
		case At_evalex:
		case At_foceval:
		case At_return:
		case At_iserror:
		case At_isavailable:
		case At_isunavailable:
		case At_other:
		case OpPlus:
		case OpMinus:
		case NumDoubleUS:
		case NumDoubleDE:
		case NumInteger:
		case String1:
		case String2:
		case Identifier:
			opCmp();
			break;
		default:
			jj_la1[17] = jj_gen;
			jj_consume_token(-1);
			throw new ParseException();
		}
	}

	final private void opHasNot() throws ParseException {
		jj_consume_token(BoolNot);
		opNot();
		ASTOperator jjtn001 = new ASTOperator(this, JJTOPERATOR);
		boolean jjtc001 = true;
		jjtree.openNodeScope(jjtn001);
		try {
			jjtree.closeNodeScope(jjtn001, 1);
			jjtc001 = false;
			jjtn001.init(" !");
		} finally {
			if (jjtc001) {
				jjtree.closeNodeScope(jjtn001, 1);
			}
		}
	}

	final private void opCmp() throws ParseException {
		opAdd();
		label_8: while (true) {
			switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
			case CmpEqual:
			case CmpEqualP:
			case CmpNE:
			case CmpNEP:
			case CmpLT:
			case CmpLTP:
			case CmpGT:
			case CmpGTP:
			case CmpLTE:
			case CmpLTEP:
			case CmpGTE:
			case CmpGTEP:
				;
				break;
			default:
				jj_la1[18] = jj_gen;
				break label_8;
			}
			ASTOperator jjtn001 = new ASTOperator(this, JJTOPERATOR);
			boolean jjtc001 = true;
			jjtree.openNodeScope(jjtn001);
			try {
				switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
				case CmpEqual:
					jj_consume_token(CmpEqual);
					opAdd();
					jjtree.closeNodeScope(jjtn001, 2);
					jjtc001 = false;
					jjtn001.init("=");
					break;
				case CmpEqualP:
					jj_consume_token(CmpEqualP);
					opAdd();
					jjtree.closeNodeScope(jjtn001, 2);
					jjtc001 = false;
					jjtn001.init("*=");
					break;
				case CmpNE:
					jj_consume_token(CmpNE);
					opAdd();
					jjtree.closeNodeScope(jjtn001, 2);
					jjtc001 = false;
					jjtn001.init("<>");
					break;
				case CmpNEP:
					jj_consume_token(CmpNEP);
					opAdd();
					jjtree.closeNodeScope(jjtn001, 2);
					jjtc001 = false;
					jjtn001.init("*<>");
					break;
				case CmpLT:
					jj_consume_token(CmpLT);
					opAdd();
					jjtree.closeNodeScope(jjtn001, 2);
					jjtc001 = false;
					jjtn001.init("<");
					break;
				case CmpLTP:
					jj_consume_token(CmpLTP);
					opAdd();
					jjtree.closeNodeScope(jjtn001, 2);
					jjtc001 = false;
					jjtn001.init("*<");
					break;
				case CmpGT:
					jj_consume_token(CmpGT);
					opAdd();
					jjtree.closeNodeScope(jjtn001, 2);
					jjtc001 = false;
					jjtn001.init(">");
					break;
				case CmpGTP:
					jj_consume_token(CmpGTP);
					opAdd();
					jjtree.closeNodeScope(jjtn001, 2);
					jjtc001 = false;
					jjtn001.init("*>");
					break;
				case CmpLTE:
					jj_consume_token(CmpLTE);
					opAdd();
					jjtree.closeNodeScope(jjtn001, 2);
					jjtc001 = false;
					jjtn001.init("<=");
					break;
				case CmpLTEP:
					jj_consume_token(CmpLTEP);
					opAdd();
					jjtree.closeNodeScope(jjtn001, 2);
					jjtc001 = false;
					jjtn001.init("*<=");
					break;
				case CmpGTE:
					jj_consume_token(CmpGTE);
					opAdd();
					jjtree.closeNodeScope(jjtn001, 2);
					jjtc001 = false;
					jjtn001.init(">=");
					break;
				case CmpGTEP:
					jj_consume_token(CmpGTEP);
					opAdd();
					jjtree.closeNodeScope(jjtn001, 2);
					jjtc001 = false;
					jjtn001.init("*>=");
					break;
				default:
					jj_la1[19] = jj_gen;
					jj_consume_token(-1);
					throw new ParseException();
				}
			} catch (Throwable jjte001) {
				if (jjtc001) {
					jjtree.clearNodeScope(jjtn001);
					jjtc001 = false;
				} else {
					jjtree.popNode();
				}
				if (jjte001 instanceof RuntimeException) {
					{
						if (true)
							throw (RuntimeException) jjte001;
					}
				}
				if (jjte001 instanceof ParseException) {
					{
						if (true)
							throw (ParseException) jjte001;
					}
				}
				{
					if (true)
						throw (Error) jjte001;
				}
			} finally {
				if (jjtc001) {
					jjtree.closeNodeScope(jjtn001, 2);
				}
			}
		}
	}

	final private void opAdd() throws ParseException {
		opMult();
		label_9: while (true) {
			if (jj_2_4(2)) {
				;
			} else {
				break label_9;
			}
			ASTOperator jjtn001 = new ASTOperator(this, JJTOPERATOR);
			boolean jjtc001 = true;
			jjtree.openNodeScope(jjtn001);
			try {
				switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
				case OpPlus:
					jj_consume_token(OpPlus);
					opMult();
					jjtree.closeNodeScope(jjtn001, 2);
					jjtc001 = false;
					jjtn001.init("+");
					break;
				case OpPlusP:
					jj_consume_token(OpPlusP);
					opMult();
					jjtree.closeNodeScope(jjtn001, 2);
					jjtc001 = false;
					jjtn001.init("*+");
					break;
				case OpMinus:
					jj_consume_token(OpMinus);
					opMult();
					jjtree.closeNodeScope(jjtn001, 2);
					jjtc001 = false;
					jjtn001.init("-");
					break;
				case OpMinusP:
					jj_consume_token(OpMinusP);
					opMult();
					jjtree.closeNodeScope(jjtn001, 2);
					jjtc001 = false;
					jjtn001.init("*-");
					break;
				default:
					jj_la1[20] = jj_gen;
					jj_consume_token(-1);
					throw new ParseException();
				}
			} catch (Throwable jjte001) {
				if (jjtc001) {
					jjtree.clearNodeScope(jjtn001);
					jjtc001 = false;
				} else {
					jjtree.popNode();
				}
				if (jjte001 instanceof RuntimeException) {
					{
						if (true)
							throw (RuntimeException) jjte001;
					}
				}
				if (jjte001 instanceof ParseException) {
					{
						if (true)
							throw (ParseException) jjte001;
					}
				}
				{
					if (true)
						throw (Error) jjte001;
				}
			} finally {
				if (jjtc001) {
					jjtree.closeNodeScope(jjtn001, 2);
				}
			}
		}
	}

	final private void opMult() throws ParseException {
		opSign();
		label_10: while (true) {
			switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
			case OpMul:
			case OpMulP:
			case OpDiv:
			case OpDivP:
				;
				break;
			default:
				jj_la1[21] = jj_gen;
				break label_10;
			}
			ASTOperator jjtn001 = new ASTOperator(this, JJTOPERATOR);
			boolean jjtc001 = true;
			jjtree.openNodeScope(jjtn001);
			try {
				switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
				case OpMul:
					jj_consume_token(OpMul);
					opSign();
					jjtree.closeNodeScope(jjtn001, 2);
					jjtc001 = false;
					jjtn001.init("*");
					break;
				case OpMulP:
					jj_consume_token(OpMulP);
					opSign();
					jjtree.closeNodeScope(jjtn001, 2);
					jjtc001 = false;
					jjtn001.init("**");
					break;
				case OpDiv:
					jj_consume_token(OpDiv);
					opSign();
					jjtree.closeNodeScope(jjtn001, 2);
					jjtc001 = false;
					jjtn001.init("/");
					break;
				case OpDivP:
					jj_consume_token(OpDivP);
					opSign();
					jjtree.closeNodeScope(jjtn001, 2);
					jjtc001 = false;
					jjtn001.init("*/");
					break;
				default:
					jj_la1[22] = jj_gen;
					jj_consume_token(-1);
					throw new ParseException();
				}
			} catch (Throwable jjte001) {
				if (jjtc001) {
					jjtree.clearNodeScope(jjtn001);
					jjtc001 = false;
				} else {
					jjtree.popNode();
				}
				if (jjte001 instanceof RuntimeException) {
					{
						if (true)
							throw (RuntimeException) jjte001;
					}
				}
				if (jjte001 instanceof ParseException) {
					{
						if (true)
							throw (ParseException) jjte001;
					}
				}
				{
					if (true)
						throw (Error) jjte001;
				}
			} finally {
				if (jjtc001) {
					jjtree.closeNodeScope(jjtn001, 2);
				}
			}
		}
	}

	final private void opSign() throws ParseException {
		switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
		case OpPlus:
		case OpMinus:
			opHasSign();
			break;
		case Date_or_KW:
		case OParen:
		case At_do:
		case At_doWhile:
		case At_while:
		case At_for:
		case At_if:
		case At_v2if:
		case At_iferror:
		case At_transform:
		case At_sort:
		case At_text:
		case At_eval:
		case At_evalex:
		case At_foceval:
		case At_return:
		case At_iserror:
		case At_isavailable:
		case At_isunavailable:
		case At_other:
		case NumDoubleUS:
		case NumDoubleDE:
		case NumInteger:
		case String1:
		case String2:
		case Identifier:
			valueList();
			break;
		default:
			jj_la1[23] = jj_gen;
			jj_consume_token(-1);
			throw new ParseException();
		}
	}

	final private void opHasSign() throws ParseException {
		switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
		case OpPlus:
			jj_consume_token(OpPlus);
			opSign();
			break;
		case OpMinus:
			jj_consume_token(OpMinus);
			opSign();
			ASTOperator jjtn001 = new ASTOperator(this, JJTOPERATOR);
			boolean jjtc001 = true;
			jjtree.openNodeScope(jjtn001);
			try {
				jjtree.closeNodeScope(jjtn001, 1);
				jjtc001 = false;
				jjtn001.init(" -");
			} finally {
				if (jjtc001) {
					jjtree.closeNodeScope(jjtn001, 1);
				}
			}
			break;
		default:
			jj_la1[24] = jj_gen;
			jj_consume_token(-1);
			throw new ParseException();
		}
	}

	final private void valueList() throws ParseException {
		ASTValueList jjtn001 = new ASTValueList(this, JJTVALUELIST);
		boolean jjtc001 = true;
		jjtree.openNodeScope(jjtn001);
		try {
			subscript();
			label_11: while (true) {
				if (jj_2_5(2)) {
					;
				} else {
					break label_11;
				}
				jj_consume_token(ListConcat);
				switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
				case OpPlus:
				case OpMinus:
					opHasSign();
					break;
				case Date_or_KW:
				case OParen:
				case At_do:
				case At_doWhile:
				case At_while:
				case At_for:
				case At_if:
				case At_v2if:
				case At_iferror:
				case At_transform:
				case At_sort:
				case At_text:
				case At_eval:
				case At_evalex:
				case At_foceval:
				case At_return:
				case At_iserror:
				case At_isavailable:
				case At_isunavailable:
				case At_other:
				case NumDoubleUS:
				case NumDoubleDE:
				case NumInteger:
				case String1:
				case String2:
				case Identifier:
					subscript();
					break;
				default:
					jj_la1[25] = jj_gen;
					jj_consume_token(-1);
					throw new ParseException();
				}
			}
		} catch (Throwable jjte001) {
			if (jjtc001) {
				jjtree.clearNodeScope(jjtn001);
				jjtc001 = false;
			} else {
				jjtree.popNode();
			}
			if (jjte001 instanceof RuntimeException) {
				{
					if (true)
						throw (RuntimeException) jjte001;
				}
			}
			if (jjte001 instanceof ParseException) {
				{
					if (true)
						throw (ParseException) jjte001;
				}
			}
			{
				if (true)
					throw (Error) jjte001;
			}
		} finally {
			if (jjtc001) {
				jjtree.closeNodeScope(jjtn001, jjtree.nodeArity() > 1);
			}
		}
	}

	final private void subscript() throws ParseException {
		ASTSubscript jjtn001 = new ASTSubscript(this, JJTSUBSCRIPT);
		boolean jjtc001 = true;
		jjtree.openNodeScope(jjtn001);
		try {
			unary();
			label_12: while (true) {
				switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
				case OSubscript:
					;
					break;
				default:
					jj_la1[26] = jj_gen;
					break label_12;
				}
				jj_consume_token(OSubscript);
				statement();
				jj_consume_token(CSubscript);
			}
		} catch (Throwable jjte001) {
			if (jjtc001) {
				jjtree.clearNodeScope(jjtn001);
				jjtc001 = false;
			} else {
				jjtree.popNode();
			}
			if (jjte001 instanceof RuntimeException) {
				{
					if (true)
						throw (RuntimeException) jjte001;
				}
			}
			if (jjte001 instanceof ParseException) {
				{
					if (true)
						throw (ParseException) jjte001;
				}
			}
			{
				if (true)
					throw (Error) jjte001;
			}
		} finally {
			if (jjtc001) {
				jjtree.closeNodeScope(jjtn001, jjtree.nodeArity() > 1);
			}
		}
	}

	final private void unary() throws ParseException {
		switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
		case At_do:
			jj_consume_token(At_do);
			ASTAtDo jjtn001 = new ASTAtDo(this, JJTATDO);
			boolean jjtc001 = true;
			jjtree.openNodeScope(jjtn001);
			try {
				jj_consume_token(OParen);
				statement();
				label_13: while (true) {
					switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
					case EOS:
						;
						break;
					default:
						jj_la1[27] = jj_gen;
						break label_13;
					}
					jj_consume_token(EOS);
					statement();
				}
				jj_consume_token(CParen);
			} catch (Throwable jjte001) {
				if (jjtc001) {
					jjtree.clearNodeScope(jjtn001);
					jjtc001 = false;
				} else {
					jjtree.popNode();
				}
				if (jjte001 instanceof RuntimeException) {
					{
						if (true)
							throw (RuntimeException) jjte001;
					}
				}
				if (jjte001 instanceof ParseException) {
					{
						if (true)
							throw (ParseException) jjte001;
					}
				}
				{
					if (true)
						throw (Error) jjte001;
				}
			} finally {
				if (jjtc001) {
					jjtree.closeNodeScope(jjtn001, true);
				}
			}
			break;
		case At_doWhile:
			jj_consume_token(At_doWhile);
			ASTAtDoWhile jjtn002 = new ASTAtDoWhile(this, JJTATDOWHILE);
			boolean jjtc002 = true;
			jjtree.openNodeScope(jjtn002);
			try {
				jj_consume_token(OParen);
				statement();
				label_14: while (true) {
					switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
					case EOS:
						;
						break;
					default:
						jj_la1[28] = jj_gen;
						break label_14;
					}
					jj_consume_token(EOS);
					statement();
				}
				jj_consume_token(CParen);
			} catch (Throwable jjte002) {
				if (jjtc002) {
					jjtree.clearNodeScope(jjtn002);
					jjtc002 = false;
				} else {
					jjtree.popNode();
				}
				if (jjte002 instanceof RuntimeException) {
					{
						if (true)
							throw (RuntimeException) jjte002;
					}
				}
				if (jjte002 instanceof ParseException) {
					{
						if (true)
							throw (ParseException) jjte002;
					}
				}
				{
					if (true)
						throw (Error) jjte002;
				}
			} finally {
				if (jjtc002) {
					jjtree.closeNodeScope(jjtn002, true);
				}
			}
			break;
		case At_while:
			jj_consume_token(At_while);
			ASTAtWhile jjtn003 = new ASTAtWhile(this, JJTATWHILE);
			boolean jjtc003 = true;
			jjtree.openNodeScope(jjtn003);
			try {
				jj_consume_token(OParen);
				statement();
				label_15: while (true) {
					switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
					case EOS:
						;
						break;
					default:
						jj_la1[29] = jj_gen;
						break label_15;
					}
					jj_consume_token(EOS);
					statement();
				}
				jj_consume_token(CParen);
			} catch (Throwable jjte003) {
				if (jjtc003) {
					jjtree.clearNodeScope(jjtn003);
					jjtc003 = false;
				} else {
					jjtree.popNode();
				}
				if (jjte003 instanceof RuntimeException) {
					{
						if (true)
							throw (RuntimeException) jjte003;
					}
				}
				if (jjte003 instanceof ParseException) {
					{
						if (true)
							throw (ParseException) jjte003;
					}
				}
				{
					if (true)
						throw (Error) jjte003;
				}
			} finally {
				if (jjtc003) {
					jjtree.closeNodeScope(jjtn003, true);
				}
			}
			break;
		case At_for:
			jj_consume_token(At_for);
			ASTAtFor jjtn004 = new ASTAtFor(this, JJTATFOR);
			boolean jjtc004 = true;
			jjtree.openNodeScope(jjtn004);
			try {
				jj_consume_token(OParen);
				statement();
				jj_consume_token(EOS);
				statement();
				jj_consume_token(EOS);
				statement();
				label_16: while (true) {
					switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
					case EOS:
						;
						break;
					default:
						jj_la1[30] = jj_gen;
						break label_16;
					}
					jj_consume_token(EOS);
					statement();
				}
				jj_consume_token(CParen);
			} catch (Throwable jjte004) {
				if (jjtc004) {
					jjtree.clearNodeScope(jjtn004);
					jjtc004 = false;
				} else {
					jjtree.popNode();
				}
				if (jjte004 instanceof RuntimeException) {
					{
						if (true)
							throw (RuntimeException) jjte004;
					}
				}
				if (jjte004 instanceof ParseException) {
					{
						if (true)
							throw (ParseException) jjte004;
					}
				}
				{
					if (true)
						throw (Error) jjte004;
				}
			} finally {
				if (jjtc004) {
					jjtree.closeNodeScope(jjtn004, true);
				}
			}
			break;
		case At_if:
		case At_v2if:
			switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
			case At_if:
				jj_consume_token(At_if);
				break;
			case At_v2if:
				jj_consume_token(At_v2if);
				break;
			default:
				jj_la1[31] = jj_gen;
				jj_consume_token(-1);
				throw new ParseException();
			}
			ASTAtIf jjtn005 = new ASTAtIf(this, JJTATIF);
			boolean jjtc005 = true;
			jjtree.openNodeScope(jjtn005);
			try {
				jj_consume_token(OParen);
				statement();
				label_17: while (true) {
					jj_consume_token(EOS);
					statement();
					jj_consume_token(EOS);
					statement();
					switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
					case EOS:
						;
						break;
					default:
						jj_la1[32] = jj_gen;
						break label_17;
					}
				}
				jj_consume_token(CParen);
			} catch (Throwable jjte005) {
				if (jjtc005) {
					jjtree.clearNodeScope(jjtn005);
					jjtc005 = false;
				} else {
					jjtree.popNode();
				}
				if (jjte005 instanceof RuntimeException) {
					{
						if (true)
							throw (RuntimeException) jjte005;
					}
				}
				if (jjte005 instanceof ParseException) {
					{
						if (true)
							throw (ParseException) jjte005;
					}
				}
				{
					if (true)
						throw (Error) jjte005;
				}
			} finally {
				if (jjtc005) {
					jjtree.closeNodeScope(jjtn005, true);
				}
			}
			break;
		case At_iferror:
			jj_consume_token(At_iferror);
			ASTAtIfError jjtn006 = new ASTAtIfError(this, JJTATIFERROR);
			boolean jjtc006 = true;
			jjtree.openNodeScope(jjtn006);
			try {
				jj_consume_token(OParen);
				statement();
				switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
				case EOS:
					jj_consume_token(EOS);
					statement();
					break;
				default:
					jj_la1[33] = jj_gen;
					;
				}
				jj_consume_token(CParen);
			} catch (Throwable jjte006) {
				if (jjtc006) {
					jjtree.clearNodeScope(jjtn006);
					jjtc006 = false;
				} else {
					jjtree.popNode();
				}
				if (jjte006 instanceof RuntimeException) {
					{
						if (true)
							throw (RuntimeException) jjte006;
					}
				}
				if (jjte006 instanceof ParseException) {
					{
						if (true)
							throw (ParseException) jjte006;
					}
				}
				{
					if (true)
						throw (Error) jjte006;
				}
			} finally {
				if (jjtc006) {
					jjtree.closeNodeScope(jjtn006, true);
				}
			}
			break;
		case At_transform:
			jj_consume_token(At_transform);
			ASTAtTransform jjtn007 = new ASTAtTransform(this, JJTATTRANSFORM);
			boolean jjtc007 = true;
			jjtree.openNodeScope(jjtn007);
			try {
				jj_consume_token(OParen);
				statement();
				jj_consume_token(EOS);
				statement();
				jj_consume_token(EOS);
				statement();
				jj_consume_token(CParen);
			} catch (Throwable jjte007) {
				if (jjtc007) {
					jjtree.clearNodeScope(jjtn007);
					jjtc007 = false;
				} else {
					jjtree.popNode();
				}
				if (jjte007 instanceof RuntimeException) {
					{
						if (true)
							throw (RuntimeException) jjte007;
					}
				}
				if (jjte007 instanceof ParseException) {
					{
						if (true)
							throw (ParseException) jjte007;
					}
				}
				{
					if (true)
						throw (Error) jjte007;
				}
			} finally {
				if (jjtc007) {
					jjtree.closeNodeScope(jjtn007, true);
				}
			}
			break;
		case At_sort:
			jj_consume_token(At_sort);
			ASTAtSort jjtn008 = new ASTAtSort(this, JJTATSORT);
			boolean jjtc008 = true;
			jjtree.openNodeScope(jjtn008);
			try {
				jj_consume_token(OParen);
				statement();
				switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
				case EOS:
					jj_consume_token(EOS);
					statement();
					switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
					case EOS:
						jj_consume_token(EOS);
						statement();
						break;
					default:
						jj_la1[34] = jj_gen;
						;
					}
					break;
				default:
					jj_la1[35] = jj_gen;
					;
				}
				jj_consume_token(CParen);
			} catch (Throwable jjte008) {
				if (jjtc008) {
					jjtree.clearNodeScope(jjtn008);
					jjtc008 = false;
				} else {
					jjtree.popNode();
				}
				if (jjte008 instanceof RuntimeException) {
					{
						if (true)
							throw (RuntimeException) jjte008;
					}
				}
				if (jjte008 instanceof ParseException) {
					{
						if (true)
							throw (ParseException) jjte008;
					}
				}
				{
					if (true)
						throw (Error) jjte008;
				}
			} finally {
				if (jjtc008) {
					jjtree.closeNodeScope(jjtn008, true);
				}
			}
			break;
		case At_eval:
			jj_consume_token(At_eval);
			ASTAtEval jjtn009 = new ASTAtEval(this, JJTATEVAL);
			boolean jjtc009 = true;
			jjtree.openNodeScope(jjtn009);
			try {
				jj_consume_token(OParen);
				statement();
				jj_consume_token(CParen);
			} catch (Throwable jjte009) {
				if (jjtc009) {
					jjtree.clearNodeScope(jjtn009);
					jjtc009 = false;
				} else {
					jjtree.popNode();
				}
				if (jjte009 instanceof RuntimeException) {
					{
						if (true)
							throw (RuntimeException) jjte009;
					}
				}
				if (jjte009 instanceof ParseException) {
					{
						if (true)
							throw (ParseException) jjte009;
					}
				}
				{
					if (true)
						throw (Error) jjte009;
				}
			} finally {
				if (jjtc009) {
					jjtree.closeNodeScope(jjtn009, true);
				}
			}
			break;
		case At_evalex:
			jj_consume_token(At_evalex);
			ASTAtEvalEx jjtn010 = new ASTAtEvalEx(this, JJTATEVALEX);
			boolean jjtc010 = true;
			jjtree.openNodeScope(jjtn010);
			try {
				jj_consume_token(OParen);
				statement();
				label_18: while (true) {
					switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
					case EOS:
						;
						break;
					default:
						jj_la1[36] = jj_gen;
						break label_18;
					}
					jj_consume_token(EOS);
					statement();
				}
				jj_consume_token(CParen);
			} catch (Throwable jjte010) {
				if (jjtc010) {
					jjtree.clearNodeScope(jjtn010);
					jjtc010 = false;
				} else {
					jjtree.popNode();
				}
				if (jjte010 instanceof RuntimeException) {
					{
						if (true)
							throw (RuntimeException) jjte010;
					}
				}
				if (jjte010 instanceof ParseException) {
					{
						if (true)
							throw (ParseException) jjte010;
					}
				}
				{
					if (true)
						throw (Error) jjte010;
				}
			} finally {
				if (jjtc010) {
					jjtree.closeNodeScope(jjtn010, true);
				}
			}
			break;
		case At_foceval:
			jj_consume_token(At_foceval);
			ASTAtFocEval jjtn011 = new ASTAtFocEval(this, JJTATFOCEVAL);
			boolean jjtc011 = true;
			jjtree.openNodeScope(jjtn011);
			try {
				jj_consume_token(OParen);
				statement();
				jj_consume_token(CParen);
			} catch (Throwable jjte011) {
				if (jjtc011) {
					jjtree.clearNodeScope(jjtn011);
					jjtc011 = false;
				} else {
					jjtree.popNode();
				}
				if (jjte011 instanceof RuntimeException) {
					{
						if (true)
							throw (RuntimeException) jjte011;
					}
				}
				if (jjte011 instanceof ParseException) {
					{
						if (true)
							throw (ParseException) jjte011;
					}
				}
				{
					if (true)
						throw (Error) jjte011;
				}
			} finally {
				if (jjtc011) {
					jjtree.closeNodeScope(jjtn011, true);
				}
			}
			break;
		case At_text:
			jj_consume_token(At_text);
			ASTAtText jjtn012 = new ASTAtText(this, JJTATTEXT);
			boolean jjtc012 = true;
			jjtree.openNodeScope(jjtn012);
			try {
				jj_consume_token(OParen);
				statement();
				switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
				case EOS:
					jj_consume_token(EOS);
					statement();
					break;
				default:
					jj_la1[37] = jj_gen;
					;
				}
				jj_consume_token(CParen);
			} catch (Throwable jjte012) {
				if (jjtc012) {
					jjtree.clearNodeScope(jjtn012);
					jjtc012 = false;
				} else {
					jjtree.popNode();
				}
				if (jjte012 instanceof RuntimeException) {
					{
						if (true)
							throw (RuntimeException) jjte012;
					}
				}
				if (jjte012 instanceof ParseException) {
					{
						if (true)
							throw (ParseException) jjte012;
					}
				}
				{
					if (true)
						throw (Error) jjte012;
				}
			} finally {
				if (jjtc012) {
					jjtree.closeNodeScope(jjtn012, true);
				}
			}
			break;
		case At_return:
			jj_consume_token(At_return);
			ASTAtReturn jjtn013 = new ASTAtReturn(this, JJTATRETURN);
			boolean jjtc013 = true;
			jjtree.openNodeScope(jjtn013);
			try {
				jj_consume_token(OParen);
				statement();
				jj_consume_token(CParen);
			} catch (Throwable jjte013) {
				if (jjtc013) {
					jjtree.clearNodeScope(jjtn013);
					jjtc013 = false;
				} else {
					jjtree.popNode();
				}
				if (jjte013 instanceof RuntimeException) {
					{
						if (true)
							throw (RuntimeException) jjte013;
					}
				}
				if (jjte013 instanceof ParseException) {
					{
						if (true)
							throw (ParseException) jjte013;
					}
				}
				{
					if (true)
						throw (Error) jjte013;
				}
			} finally {
				if (jjtc013) {
					jjtree.closeNodeScope(jjtn013, true);
				}
			}
			break;
		case At_iserror:
			jj_consume_token(At_iserror);
			ASTAtIsError jjtn014 = new ASTAtIsError(this, JJTATISERROR);
			boolean jjtc014 = true;
			jjtree.openNodeScope(jjtn014);
			try {
				jj_consume_token(OParen);
				statement();
				jj_consume_token(CParen);
			} catch (Throwable jjte014) {
				if (jjtc014) {
					jjtree.clearNodeScope(jjtn014);
					jjtc014 = false;
				} else {
					jjtree.popNode();
				}
				if (jjte014 instanceof RuntimeException) {
					{
						if (true)
							throw (RuntimeException) jjte014;
					}
				}
				if (jjte014 instanceof ParseException) {
					{
						if (true)
							throw (ParseException) jjte014;
					}
				}
				{
					if (true)
						throw (Error) jjte014;
				}
			} finally {
				if (jjtc014) {
					jjtree.closeNodeScope(jjtn014, true);
				}
			}
			break;
		case At_isavailable:
			jj_consume_token(At_isavailable);
			ASTAtIsAvailable jjtn015 = new ASTAtIsAvailable(this, JJTATISAVAILABLE);
			boolean jjtc015 = true;
			jjtree.openNodeScope(jjtn015);
			try {
				jj_consume_token(OParen);
				statement();
				jj_consume_token(CParen);
			} catch (Throwable jjte015) {
				if (jjtc015) {
					jjtree.clearNodeScope(jjtn015);
					jjtc015 = false;
				} else {
					jjtree.popNode();
				}
				if (jjte015 instanceof RuntimeException) {
					{
						if (true)
							throw (RuntimeException) jjte015;
					}
				}
				if (jjte015 instanceof ParseException) {
					{
						if (true)
							throw (ParseException) jjte015;
					}
				}
				{
					if (true)
						throw (Error) jjte015;
				}
			} finally {
				if (jjtc015) {
					jjtree.closeNodeScope(jjtn015, true);
				}
			}
			break;
		case At_isunavailable:
			jj_consume_token(At_isunavailable);
			ASTAtIsUnavailable jjtn016 = new ASTAtIsUnavailable(this, JJTATISUNAVAILABLE);
			boolean jjtc016 = true;
			jjtree.openNodeScope(jjtn016);
			try {
				jj_consume_token(OParen);
				statement();
				jj_consume_token(CParen);
			} catch (Throwable jjte016) {
				if (jjtc016) {
					jjtree.clearNodeScope(jjtn016);
					jjtc016 = false;
				} else {
					jjtree.popNode();
				}
				if (jjte016 instanceof RuntimeException) {
					{
						if (true)
							throw (RuntimeException) jjte016;
					}
				}
				if (jjte016 instanceof ParseException) {
					{
						if (true)
							throw (ParseException) jjte016;
					}
				}
				{
					if (true)
						throw (Error) jjte016;
				}
			} finally {
				if (jjtc016) {
					jjtree.closeNodeScope(jjtn016, true);
				}
			}
			break;
		case At_other:
			jj_consume_token(At_other);
			formula();
			break;
		case Date_or_KW:
		case OParen:
		case NumDoubleUS:
		case NumDoubleDE:
		case NumInteger:
		case String1:
		case String2:
		case Identifier:
			atom();
			break;
		default:
			jj_la1[38] = jj_gen;
			jj_consume_token(-1);
			throw new ParseException();
		}
	}

	final private void formula() throws ParseException {
		/*@bgen(jjtree) Function */
		ASTFunction jjtn000 = new ASTFunction(this, JJTFUNCTION);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		Token t;
		try {
			t = getToken(0);
			if (jj_2_6(2)) {
				jj_consume_token(OParen);
				statement();
				label_19: while (true) {
					switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
					case EOS:
						;
						break;
					default:
						jj_la1[39] = jj_gen;
						break label_19;
					}
					jj_consume_token(EOS);
					statement();
				}
				jj_consume_token(CParen);
			} else {
				;
			}
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			jjtn000.init(t.image);
		} catch (Throwable jjte000) {
			if (jjtc000) {
				jjtree.clearNodeScope(jjtn000);
				jjtc000 = false;
			} else {
				jjtree.popNode();
			}
			if (jjte000 instanceof RuntimeException) {
				{
					if (true)
						throw (RuntimeException) jjte000;
				}
			}
			if (jjte000 instanceof ParseException) {
				{
					if (true)
						throw (ParseException) jjte000;
				}
			}
			{
				if (true)
					throw (Error) jjte000;
			}
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}
	}

	final private void atom() throws ParseException {
		switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
		case Date_or_KW:
		case NumDoubleUS:
		case NumDoubleDE:
		case NumInteger:
		case String1:
		case String2:
		case Identifier:
			value();
			break;
		case OParen:
			jj_consume_token(OParen);
			statement();
			jj_consume_token(CParen);
			break;
		default:
			jj_la1[40] = jj_gen;
			jj_consume_token(-1);
			throw new ParseException();
		}
	}

	final private void value() throws ParseException {
		Token t;
		switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
		case Date_or_KW:
			t = jj_consume_token(Date_or_KW);
			ASTValueDateOrKW jjtn001 = new ASTValueDateOrKW(this, JJTVALUEDATEORKW);
			boolean jjtc001 = true;
			jjtree.openNodeScope(jjtn001);
			try {
				jjtree.closeNodeScope(jjtn001, true);
				jjtc001 = false;
				jjtn001.init(t.image);
			} finally {
				if (jjtc001) {
					jjtree.closeNodeScope(jjtn001, true);
				}
			}
			break;
		case String1:
			t = jj_consume_token(String1);
			ASTValueString jjtn002 = new ASTValueString(this, JJTVALUESTRING);
			boolean jjtc002 = true;
			jjtree.openNodeScope(jjtn002);
			try {
				jjtree.closeNodeScope(jjtn002, true);
				jjtc002 = false;
				jjtn002.parseString(t.image, '"');
			} finally {
				if (jjtc002) {
					jjtree.closeNodeScope(jjtn002, true);
				}
			}
			break;
		case String2:
			t = jj_consume_token(String2);
			ASTValueString jjtn003 = new ASTValueString(this, JJTVALUESTRING);
			boolean jjtc003 = true;
			jjtree.openNodeScope(jjtn003);
			try {
				jjtree.closeNodeScope(jjtn003, true);
				jjtc003 = false;
				jjtn003.parseString(t.image, '{');
			} finally {
				if (jjtc003) {
					jjtree.closeNodeScope(jjtn003, true);
				}
			}
			break;
		case NumDoubleUS:
			t = jj_consume_token(NumDoubleUS);
			ASTValueDouble jjtn004 = new ASTValueDouble(this, JJTVALUEDOUBLE);
			boolean jjtc004 = true;
			jjtree.openNodeScope(jjtn004);
			try {
				jjtree.closeNodeScope(jjtn004, true);
				jjtc004 = false;
				jjtn004.parseDouble(t.image, '.');
			} finally {
				if (jjtc004) {
					jjtree.closeNodeScope(jjtn004, true);
				}
			}
			break;
		case NumDoubleDE:
			t = jj_consume_token(NumDoubleDE);
			ASTValueDouble jjtn005 = new ASTValueDouble(this, JJTVALUEDOUBLE);
			boolean jjtc005 = true;
			jjtree.openNodeScope(jjtn005);
			try {
				jjtree.closeNodeScope(jjtn005, true);
				jjtc005 = false;
				jjtn005.parseDouble(t.image, ',');
			} finally {
				if (jjtc005) {
					jjtree.closeNodeScope(jjtn005, true);
				}
			}
			break;
		case NumInteger:
			t = jj_consume_token(NumInteger);
			ASTValueInt jjtn006 = new ASTValueInt(this, JJTVALUEINT);
			boolean jjtc006 = true;
			jjtree.openNodeScope(jjtn006);
			try {
				jjtree.closeNodeScope(jjtn006, true);
				jjtc006 = false;
				jjtn006.parseInt(t.image);
			} finally {
				if (jjtc006) {
					jjtree.closeNodeScope(jjtn006, true);
				}
			}
			break;
		case Identifier:
			t = jj_consume_token(Identifier);
			ASTGetVariable jjtn007 = new ASTGetVariable(this, JJTGETVARIABLE);
			boolean jjtc007 = true;
			jjtree.openNodeScope(jjtn007);
			try {
				jjtree.closeNodeScope(jjtn007, true);
				jjtc007 = false;
				jjtn007.init(t.image);
			} finally {
				if (jjtc007) {
					jjtree.closeNodeScope(jjtn007, true);
				}
			}
			break;
		default:
			jj_la1[41] = jj_gen;
			jj_consume_token(-1);
			throw new ParseException();
		}
	}

	private boolean jj_2_1(final int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_1();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(0, xla);
		}
	}

	private boolean jj_2_2(final int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_2();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(1, xla);
		}
	}

	private boolean jj_2_3(final int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_3();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(2, xla);
		}
	}

	private boolean jj_2_4(final int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_4();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(3, xla);
		}
	}

	private boolean jj_2_5(final int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_5();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(4, xla);
		}
	}

	private boolean jj_2_6(final int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_6();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(5, xla);
		}
	}

	private boolean jj_3R_77() {
		if (jj_scan_token(NumDoubleDE))
			return true;
		return false;
	}

	private boolean jj_3R_70() {
		if (jj_3R_72())
			return true;
		return false;
	}

	private boolean jj_3R_76() {
		if (jj_scan_token(NumDoubleUS))
			return true;
		return false;
	}

	private boolean jj_3_5() {
		if (jj_scan_token(ListConcat))
			return true;
		Token xsp;
		xsp = jj_scanpos;
		if (jj_3R_24()) {
			jj_scanpos = xsp;
			if (jj_3R_25())
				return true;
		}
		return false;
	}

	private boolean jj_3R_69() {
		if (jj_scan_token(BoolNot))
			return true;
		return false;
	}

	private boolean jj_3R_75() {
		if (jj_scan_token(String2))
			return true;
		return false;
	}

	private boolean jj_3R_29() {
		if (jj_3R_40())
			return true;
		return false;
	}

	private boolean jj_3R_74() {
		if (jj_scan_token(String1))
			return true;
		return false;
	}

	private boolean jj_3R_66() {
		if (jj_3R_70())
			return true;
		return false;
	}

	private boolean jj_3R_73() {
		if (jj_scan_token(Date_or_KW))
			return true;
		return false;
	}

	private boolean jj_3R_71() {
		Token xsp;
		xsp = jj_scanpos;
		if (jj_3R_73()) {
			jj_scanpos = xsp;
			if (jj_3R_74()) {
				jj_scanpos = xsp;
				if (jj_3R_75()) {
					jj_scanpos = xsp;
					if (jj_3R_76()) {
						jj_scanpos = xsp;
						if (jj_3R_77()) {
							jj_scanpos = xsp;
							if (jj_3R_78()) {
								jj_scanpos = xsp;
								if (jj_3R_79())
									return true;
							}
						}
					}
				}
			}
		}
		return false;
	}

	private boolean jj_3R_65() {
		if (jj_3R_69())
			return true;
		return false;
	}

	private boolean jj_3R_62() {
		Token xsp;
		xsp = jj_scanpos;
		if (jj_3R_65()) {
			jj_scanpos = xsp;
			if (jj_3R_66())
				return true;
		}
		return false;
	}

	private boolean jj_3R_63() {
		if (jj_3R_29())
			return true;
		return false;
	}

	private boolean jj_3R_68() {
		if (jj_scan_token(OParen))
			return true;
		return false;
	}

	private boolean jj_3R_67() {
		if (jj_3R_71())
			return true;
		return false;
	}

	private boolean jj_3R_64() {
		Token xsp;
		xsp = jj_scanpos;
		if (jj_3R_67()) {
			jj_scanpos = xsp;
			if (jj_3R_68())
				return true;
		}
		return false;
	}

	private boolean jj_3R_39() {
		if (jj_scan_token(OpMinus))
			return true;
		return false;
	}

	private boolean jj_3R_28() {
		Token xsp;
		xsp = jj_scanpos;
		if (jj_3R_38()) {
			jj_scanpos = xsp;
			if (jj_3R_39())
				return true;
		}
		return false;
	}

	private boolean jj_3R_38() {
		if (jj_scan_token(OpPlus))
			return true;
		return false;
	}

	private boolean jj_3_6() {
		if (jj_scan_token(OParen))
			return true;
		if (jj_3R_26())
			return true;
		return false;
	}

	private boolean jj_3R_41() {
		if (jj_3R_62())
			return true;
		return false;
	}

	private boolean jj_3R_43() {
		if (jj_3R_63())
			return true;
		return false;
	}

	private boolean jj_3_3() {
		if (jj_scan_token(Identifier))
			return true;
		if (jj_scan_token(Assign))
			return true;
		return false;
	}

	private boolean jj_3R_37() {
		Token xsp;
		xsp = jj_scanpos;
		if (jj_3R_42()) {
			jj_scanpos = xsp;
			if (jj_3R_43())
				return true;
		}
		return false;
	}

	private boolean jj_3R_42() {
		if (jj_3R_28())
			return true;
		return false;
	}

	private boolean jj_3R_23() {
		if (jj_scan_token(OpMinusP))
			return true;
		if (jj_3R_27())
			return true;
		return false;
	}

	private boolean jj_3R_22() {
		if (jj_scan_token(OpMinus))
			return true;
		if (jj_3R_27())
			return true;
		return false;
	}

	private boolean jj_3R_21() {
		if (jj_scan_token(OpPlusP))
			return true;
		if (jj_3R_27())
			return true;
		return false;
	}

	private boolean jj_3R_20() {
		if (jj_scan_token(OpPlus))
			return true;
		if (jj_3R_27())
			return true;
		return false;
	}

	private boolean jj_3R_61() {
		if (jj_3R_64())
			return true;
		return false;
	}

	private boolean jj_3R_60() {
		if (jj_scan_token(At_other))
			return true;
		return false;
	}

	private boolean jj_3_2() {
		if (jj_scan_token(Identifier))
			return true;
		if (jj_scan_token(Assign))
			return true;
		return false;
	}

	private boolean jj_3R_59() {
		if (jj_scan_token(At_isunavailable))
			return true;
		return false;
	}

	private boolean jj_3R_58() {
		if (jj_scan_token(At_isavailable))
			return true;
		return false;
	}

	private boolean jj_3R_57() {
		if (jj_scan_token(At_iserror))
			return true;
		return false;
	}

	private boolean jj_3R_56() {
		if (jj_scan_token(At_return))
			return true;
		return false;
	}

	private boolean jj_3R_27() {
		if (jj_3R_37())
			return true;
		return false;
	}

	private boolean jj_3R_55() {
		if (jj_scan_token(At_text))
			return true;
		return false;
	}

	private boolean jj_3R_54() {
		if (jj_scan_token(At_foceval))
			return true;
		return false;
	}

	private boolean jj_3_4() {
		Token xsp;
		xsp = jj_scanpos;
		if (jj_3R_20()) {
			jj_scanpos = xsp;
			if (jj_3R_21()) {
				jj_scanpos = xsp;
				if (jj_3R_22()) {
					jj_scanpos = xsp;
					if (jj_3R_23())
						return true;
				}
			}
		}
		return false;
	}

	private boolean jj_3R_53() {
		if (jj_scan_token(At_evalex))
			return true;
		return false;
	}

	private boolean jj_3R_52() {
		if (jj_scan_token(At_eval))
			return true;
		return false;
	}

	private boolean jj_3R_25() {
		if (jj_3R_29())
			return true;
		return false;
	}

	private boolean jj_3R_51() {
		if (jj_scan_token(At_sort))
			return true;
		return false;
	}

	private boolean jj_3R_72() {
		if (jj_3R_27())
			return true;
		return false;
	}

	private boolean jj_3R_36() {
		if (jj_3R_41())
			return true;
		return false;
	}

	private boolean jj_3R_35() {
		if (jj_scan_token(KW_SELECT))
			return true;
		return false;
	}

	private boolean jj_3R_34() {
		if (jj_scan_token(KW_DEFAULT))
			return true;
		return false;
	}

	private boolean jj_3R_50() {
		if (jj_scan_token(At_transform))
			return true;
		return false;
	}

	private boolean jj_3R_33() {
		if (jj_scan_token(KW_ENVIRONMENT))
			return true;
		return false;
	}

	private boolean jj_3_1() {
		if (jj_scan_token(Identifier))
			return true;
		if (jj_scan_token(Assign))
			return true;
		return false;
	}

	private boolean jj_3R_49() {
		if (jj_scan_token(At_iferror))
			return true;
		return false;
	}

	private boolean jj_3R_32() {
		if (jj_scan_token(KW_FIELD))
			return true;
		return false;
	}

	private boolean jj_3R_24() {
		if (jj_3R_28())
			return true;
		return false;
	}

	private boolean jj_3R_48() {
		Token xsp;
		xsp = jj_scanpos;
		if (jj_scan_token(32)) {
			jj_scanpos = xsp;
			if (jj_scan_token(33))
				return true;
		}
		return false;
	}

	private boolean jj_3R_31() {
		if (jj_scan_token(At_Function))
			return true;
		return false;
	}

	private boolean jj_3R_30() {
		if (jj_scan_token(At_Include))
			return true;
		return false;
	}

	private boolean jj_3R_26() {
		Token xsp;
		xsp = jj_scanpos;
		if (jj_3R_30()) {
			jj_scanpos = xsp;
			if (jj_3R_31()) {
				jj_scanpos = xsp;
				if (jj_3R_32()) {
					jj_scanpos = xsp;
					if (jj_3_1()) {
						jj_scanpos = xsp;
						if (jj_3R_33()) {
							jj_scanpos = xsp;
							if (jj_3R_34()) {
								jj_scanpos = xsp;
								if (jj_3R_35()) {
									jj_scanpos = xsp;
									if (jj_3R_36())
										return true;
								}
							}
						}
					}
				}
			}
		}
		return false;
	}

	private boolean jj_3R_79() {
		if (jj_scan_token(Identifier))
			return true;
		return false;
	}

	private boolean jj_3R_47() {
		if (jj_scan_token(At_for))
			return true;
		return false;
	}

	private boolean jj_3R_46() {
		if (jj_scan_token(At_while))
			return true;
		return false;
	}

	private boolean jj_3R_78() {
		if (jj_scan_token(NumInteger))
			return true;
		return false;
	}

	private boolean jj_3R_45() {
		if (jj_scan_token(At_doWhile))
			return true;
		return false;
	}

	private boolean jj_3R_40() {
		Token xsp;
		xsp = jj_scanpos;
		if (jj_3R_44()) {
			jj_scanpos = xsp;
			if (jj_3R_45()) {
				jj_scanpos = xsp;
				if (jj_3R_46()) {
					jj_scanpos = xsp;
					if (jj_3R_47()) {
						jj_scanpos = xsp;
						if (jj_3R_48()) {
							jj_scanpos = xsp;
							if (jj_3R_49()) {
								jj_scanpos = xsp;
								if (jj_3R_50()) {
									jj_scanpos = xsp;
									if (jj_3R_51()) {
										jj_scanpos = xsp;
										if (jj_3R_52()) {
											jj_scanpos = xsp;
											if (jj_3R_53()) {
												jj_scanpos = xsp;
												if (jj_3R_54()) {
													jj_scanpos = xsp;
													if (jj_3R_55()) {
														jj_scanpos = xsp;
														if (jj_3R_56()) {
															jj_scanpos = xsp;
															if (jj_3R_57()) {
																jj_scanpos = xsp;
																if (jj_3R_58()) {
																	jj_scanpos = xsp;
																	if (jj_3R_59()) {
																		jj_scanpos = xsp;
																		if (jj_3R_60()) {
																			jj_scanpos = xsp;
																			if (jj_3R_61())
																				return true;
																		}
																	}
																}
															}
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
		return false;
	}

	private boolean jj_3R_44() {
		if (jj_scan_token(At_do))
			return true;
		return false;
	}

	/** Generated Token Manager. */
	public AtFormulaParserImplTokenManager token_source;
	SimpleCharStream jj_input_stream;
	/** Current token. */
	public Token token;
	/** Next token. */
	public Token jj_nt;
	private int jj_ntk;
	private Token jj_scanpos, jj_lastpos;
	private int jj_la;
	private int jj_gen;
	final private int[] jj_la1 = new int[42];
	static private int[] jj_la1_0;
	static private int[] jj_la1_1;
	static private int[] jj_la1_2;
	static {
		jj_la1_init_0();
		jj_la1_init_1();
		jj_la1_init_2();
	}

	private static void jj_la1_init_0() {
		jj_la1_0 = new int[] { 0x20000, 0x20000, 0xffe44000, 0x40000, 0xe00, 0xe00, 0x20000, 0x20000, 0x100000, 0xc800000, 0xf2644000,
				0x20000, 0x40000, 0x0, 0x0, 0x0, 0x0, 0xf0044000, 0x0, 0x0, 0x0, 0x0, 0x0, 0xf0044000, 0x0, 0xf0044000, 0x8000, 0x20000,
				0x20000, 0x20000, 0x20000, 0x0, 0x20000, 0x20000, 0x20000, 0x20000, 0x20000, 0x20000, 0xf0044000, 0x20000, 0x44000, 0x4000, };
	}

	private static void jj_la1_init_1() {
		jj_la1_1 = new int[] { 0x0, 0x0, 0x283fff, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x283fff, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x283fff,
				0xff800000, 0xff800000, 0x780000, 0x78000, 0x78000, 0x283fff, 0x280000, 0x283fff, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0,
				0x0, 0x0, 0x0, 0x0, 0x3fff, 0x0, 0x0, 0x0, };
	}

	private static void jj_la1_init_2() {
		jj_la1_2 = new int[] { 0x0, 0x0, 0x3b88, 0x1800, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3b88, 0x0, 0x0, 0x2000, 0x2000, 0x30, 0x30,
				0x3b88, 0x7, 0x7, 0x0, 0x0, 0x0, 0x3b80, 0x0, 0x3b80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3b80,
				0x0, 0x3b80, 0x3b80, };
	}

	final private JJCalls[] jj_2_rtns = new JJCalls[6];
	private boolean jj_rescan = false;
	private int jj_gc = 0;

	/** Constructor with InputStream. */
	public AtFormulaParserImpl(final java.io.InputStream stream) {
		this(stream, null);
	}

	/** Constructor with InputStream and supplied encoding */
	public AtFormulaParserImpl(final java.io.InputStream stream, final String encoding) {
		try {
			jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1);
		} catch (java.io.UnsupportedEncodingException e) {
			throw new RuntimeException(e);
		}
		token_source = new AtFormulaParserImplTokenManager(jj_input_stream);
		token = new Token();
		jj_ntk = -1;
		jj_gen = 0;
		for (int i = 0; i < 42; i++)
			jj_la1[i] = -1;
		for (int i = 0; i < jj_2_rtns.length; i++)
			jj_2_rtns[i] = new JJCalls();
	}

	/** Reinitialise. */
	public void ReInit(final java.io.InputStream stream) {
		ReInit(stream, null);
	}

	/** Reinitialise. */
	@Override
	public void ReInit(final java.io.InputStream stream, final String encoding) {
		try {
			jj_input_stream.ReInit(stream, encoding, 1, 1);
		} catch (java.io.UnsupportedEncodingException e) {
			throw new RuntimeException(e);
		}
		token_source.ReInit(jj_input_stream);
		token = new Token();
		jj_ntk = -1;
		jjtree.reset();
		jj_gen = 0;
		for (int i = 0; i < 42; i++)
			jj_la1[i] = -1;
		for (int i = 0; i < jj_2_rtns.length; i++)
			jj_2_rtns[i] = new JJCalls();
	}

	/** Constructor. */
	public AtFormulaParserImpl(final java.io.Reader stream) {
		jj_input_stream = new SimpleCharStream(stream, 1, 1);
		token_source = new AtFormulaParserImplTokenManager(jj_input_stream);
		token = new Token();
		jj_ntk = -1;
		jj_gen = 0;
		for (int i = 0; i < 42; i++)
			jj_la1[i] = -1;
		for (int i = 0; i < jj_2_rtns.length; i++)
			jj_2_rtns[i] = new JJCalls();
	}

	/** Reinitialise. */
	@Override
	public void ReInit(final java.io.Reader stream) {
		jj_input_stream.ReInit(stream, 1, 1);
		token_source.ReInit(jj_input_stream);
		token = new Token();
		jj_ntk = -1;
		jjtree.reset();
		jj_gen = 0;
		for (int i = 0; i < 42; i++)
			jj_la1[i] = -1;
		for (int i = 0; i < jj_2_rtns.length; i++)
			jj_2_rtns[i] = new JJCalls();
	}

	/** Constructor with generated Token Manager. */
	public AtFormulaParserImpl(final AtFormulaParserImplTokenManager tm) {
		token_source = tm;
		token = new Token();
		jj_ntk = -1;
		jj_gen = 0;
		for (int i = 0; i < 42; i++)
			jj_la1[i] = -1;
		for (int i = 0; i < jj_2_rtns.length; i++)
			jj_2_rtns[i] = new JJCalls();
	}

	/** Reinitialise. */
	public void ReInit(final AtFormulaParserImplTokenManager tm) {
		token_source = tm;
		token = new Token();
		jj_ntk = -1;
		jjtree.reset();
		jj_gen = 0;
		for (int i = 0; i < 42; i++)
			jj_la1[i] = -1;
		for (int i = 0; i < jj_2_rtns.length; i++)
			jj_2_rtns[i] = new JJCalls();
	}

	private Token jj_consume_token(final int kind) throws ParseException {
		Token oldToken;
		if ((oldToken = token).next != null)
			token = token.next;
		else
			token = token.next = token_source.getNextToken();
		jj_ntk = -1;
		if (token.kind == kind) {
			jj_gen++;
			if (++jj_gc > 100) {
				jj_gc = 0;
				for (int i = 0; i < jj_2_rtns.length; i++) {
					JJCalls c = jj_2_rtns[i];
					while (c != null) {
						if (c.gen < jj_gen)
							c.first = null;
						c = c.next;
					}
				}
			}
			return token;
		}
		token = oldToken;
		jj_kind = kind;
		throw generateParseException();
	}

	@SuppressWarnings("serial")
	static private final class LookaheadSuccess extends java.lang.Error {
	}

	final private LookaheadSuccess jj_ls = new LookaheadSuccess();

	private boolean jj_scan_token(final int kind) {
		if (jj_scanpos == jj_lastpos) {
			jj_la--;
			if (jj_scanpos.next == null) {
				jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
			} else {
				jj_lastpos = jj_scanpos = jj_scanpos.next;
			}
		} else {
			jj_scanpos = jj_scanpos.next;
		}
		if (jj_rescan) {
			int i = 0;
			Token tok = token;
			while (tok != null && tok != jj_scanpos) {
				i++;
				tok = tok.next;
			}
			if (tok != null)
				jj_add_error_token(kind, i);
		}
		if (jj_scanpos.kind != kind)
			return true;
		if (jj_la == 0 && jj_scanpos == jj_lastpos)
			throw jj_ls;
		return false;
	}

	/** Get the next Token. */
	final public Token getNextToken() {
		if (token.next != null)
			token = token.next;
		else
			token = token.next = token_source.getNextToken();
		jj_ntk = -1;
		jj_gen++;
		return token;
	}

	/** Get the specific Token. */
	final public Token getToken(final int index) {
		Token t = token;
		for (int i = 0; i < index; i++) {
			if (t.next != null)
				t = t.next;
			else
				t = t.next = token_source.getNextToken();
		}
		return t;
	}

	private int jj_ntk() {
		if ((jj_nt = token.next) == null)
			return (jj_ntk = (token.next = token_source.getNextToken()).kind);
		else
			return (jj_ntk = jj_nt.kind);
	}

	private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
	private int[] jj_expentry;
	private int jj_kind = -1;
	private int[] jj_lasttokens = new int[100];
	private int jj_endpos;

	private void jj_add_error_token(final int kind, final int pos) {
		if (pos >= 100)
			return;
		if (pos == jj_endpos + 1) {
			jj_lasttokens[jj_endpos++] = kind;
		} else if (jj_endpos != 0) {
			jj_expentry = new int[jj_endpos];
			for (int i = 0; i < jj_endpos; i++) {
				jj_expentry[i] = jj_lasttokens[i];
			}
			jj_entries_loop: for (java.util.Iterator<?> it = jj_expentries.iterator(); it.hasNext();) {
				int[] oldentry = (int[]) (it.next());
				if (oldentry.length == jj_expentry.length) {
					for (int i = 0; i < jj_expentry.length; i++) {
						if (oldentry[i] != jj_expentry[i]) {
							continue jj_entries_loop;
						}
					}
					jj_expentries.add(jj_expentry);
					break jj_entries_loop;
				}
			}
			if (pos != 0)
				jj_lasttokens[(jj_endpos = pos) - 1] = kind;
		}
	}

	/** Generate ParseException. */
	public ParseException generateParseException() {
		jj_expentries.clear();
		boolean[] la1tokens = new boolean[80];
		if (jj_kind >= 0) {
			la1tokens[jj_kind] = true;
			jj_kind = -1;
		}
		for (int i = 0; i < 42; i++) {
			if (jj_la1[i] == jj_gen) {
				for (int j = 0; j < 32; j++) {
					if ((jj_la1_0[i] & (1 << j)) != 0) {
						la1tokens[j] = true;
					}
					if ((jj_la1_1[i] & (1 << j)) != 0) {
						la1tokens[32 + j] = true;
					}
					if ((jj_la1_2[i] & (1 << j)) != 0) {
						la1tokens[64 + j] = true;
					}
				}
			}
		}
		for (int i = 0; i < 80; i++) {
			if (la1tokens[i]) {
				jj_expentry = new int[1];
				jj_expentry[0] = i;
				jj_expentries.add(jj_expentry);
			}
		}
		jj_endpos = 0;
		jj_rescan_token();
		jj_add_error_token(0, 0);
		int[][] exptokseq = new int[jj_expentries.size()][];
		for (int i = 0; i < jj_expentries.size(); i++) {
			exptokseq[i] = jj_expentries.get(i);
		}
		return new ParseException(token, exptokseq, tokenImage);
	}

	/** Enable tracing. */
	final public void enable_tracing() {
	}

	/** Disable tracing. */
	final public void disable_tracing() {
	}

	private void jj_rescan_token() {
		jj_rescan = true;
		for (int i = 0; i < 6; i++) {
			try {
				JJCalls p = jj_2_rtns[i];
				do {
					if (p.gen > jj_gen) {
						jj_la = p.arg;
						jj_lastpos = jj_scanpos = p.first;
						switch (i) {
						case 0:
							jj_3_1();
							break;
						case 1:
							jj_3_2();
							break;
						case 2:
							jj_3_3();
							break;
						case 3:
							jj_3_4();
							break;
						case 4:
							jj_3_5();
							break;
						case 5:
							jj_3_6();
							break;
						}
					}
					p = p.next;
				} while (p != null);
			} catch (LookaheadSuccess ls) {
			}
		}
		jj_rescan = false;
	}

	private void jj_save(final int index, final int xla) {
		JJCalls p = jj_2_rtns[index];
		while (p.gen > jj_gen) {
			if (p.next == null) {
				p = p.next = new JJCalls();
				break;
			}
			p = p.next;
		}
		p.gen = jj_gen + xla - jj_la;
		p.first = token;
		p.arg = xla;
	}

	static final class JJCalls {
		int gen;
		Token first;
		int arg;
		JJCalls next;
	}

	//  	protected AtFormulaParserImplTokenManager getTokenSource()
	//  	{
	//  	  	return token_source;
	// 	}
}
