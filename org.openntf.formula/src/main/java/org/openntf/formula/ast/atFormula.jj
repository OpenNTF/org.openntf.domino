/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. atFormula.jj */
/*@egen*/
options
{
  STATIC = false;
  JAVA_UNICODE_ESCAPE = false; // Should not pre parse the unicode escape
  UNICODE_INPUT = true; // Should accept unicode character from the Reader
  JDK_VERSION = "1.5";
  IGNORE_CASE = true;
               
                           
                                                                    
                                           
                                  
  OUTPUT_DIRECTORY = "../parse";
}

PARSER_BEGIN(AtFormulaParserImpl)
/*
 *  \u00c2\u00a9 Copyright FOCONIS AG, 2014
 * 
 * Licensed under the Apache License, Version 2.0 (the "License"); 
 * you may not use this file except in compliance with the License. 
 * You may obtain a copy of the License at:
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software 
 * distributed under the License is distributed on an "AS IS" BASIS, 
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or 
 * implied. See the License for the specific language governing 
 * permissions and limitations under the License.
 */
package org.openntf.formula.parse;
import org.openntf.formula.ast.*;

import org.openntf.formula.ast.*;
import org.openntf.formula.*;

public class AtFormulaParserImpl extends FormulaParser/*@bgen(jjtree)*/implements AtFormulaParserImplTreeConstants/*@egen*/
{/*@bgen(jjtree)*/
  protected JJTAtFormulaParserImplState jjtree = new JJTAtFormulaParserImplState();

/*@egen*/
//  	protected AtFormulaParserImplTokenManager getTokenSource()
//  	{
//  	  	return token_source;
// 	}
}

PARSER_END(AtFormulaParserImpl)

/**
 * Lexer rules. There are 4 states
 *
 * DEFAULT:
 *			The default state (formula parse mode)
 * SUBSCRIPT:
 *			Nedded to distinguish between '[Today]' (which is a date) and 'field[today]' which is a subscript
 * FOCONIS:
 *			Needed to parse Foconis' inline formulas like: 'DocumentTitle: <! subject ! >'
 * FOC_PARAM:
 *			Needed to parse Foconis' inline parameters like 'DocumentTitle: <#1#>'
 */

/**
 * Handle unneccessary characters and comments in DEFAULT and SUBSCRIPT state
 */
< DEFAULT, SUBSCRIPT >
SKIP :	{  " "| "\t"| "\n"| "\r" | "\r\n"}

< DEFAULT, SUBSCRIPT  >
SPECIAL_TOKEN : {
	<SINGLE_LINE_COMMENT: "//" (~["\n","\r"])* ("\n" | "\r" | "\r\n")?>
| 	<FORMAL_COMMENT: "/**" (~["*"])* "*" ("*" | ~["*","/"] (~["*"])* "*")* "/">
| 	<MULTI_LINE_COMMENT: "/*" (~["*"])* "*" ("*" | ~["*","/"] (~["*"])* "*")* "/">
}

/**
 * Switches from FOCONIS mode to DEFAULT or FOC_PARAM mode
 */
< FOCONIS > TOKEN :
{
  	< NORMAL_TEXT 	:   (~["<"] | "<" ~["!", "#"] | "<!--" )+  > // the "<!--" is needed to handle XML commets
|  	< BEGIN_FORMULA : "<!" > 	: DEFAULT
|   < BEGIN_PARAM 	: "<#" >	: FOC_PARAM
} 

/**
 * if we are in FOC_PARAM mode we read everything between '<#' and '#>'
 */
< FOC_PARAM > TOKEN :
{
  	< PARAM_VALUE 	:  (~["#"] | "#" ~[">"])+  >
|  	< END_PARAM 	: "#>" > : FOCONIS
}



// ======================== Handling the ugly '[date]' and 'subscript[]' thing ======================= 
/**
 * in DEFAULT mode, a "[" means that the string to the "]" is a Date or Keyword
 */
< DEFAULT > TOKEN :
{
	< Date_or_KW : "[" (~["]"])* "]" > : SUBSCRIPT	// after a Date, we are in "subscript" mode (e.g. [Today][1])
}

/**
 * in subscript mode, a "[" means that the following expression is a subscript
 * a subscript can occur after a numeric value, a string, a ")", a date, an identifier or an other subscript
 */
< SUBSCRIPT > TOKEN :
{
  	 < OSubscript : "[" > 	:  DEFAULT		// switch back immediately. Thus x[[today]] makes no sense, it is formal correct
}

/**
 * the closing bracket
 */
< DEFAULT, SUBSCRIPT > TOKEN :
{
  	// "]" must be recognized in both states
  	// consider these examples "x[(1)]": the ) switches to "SUBSCRIPT"
 	< CSubscript : "]" > :  SUBSCRIPT	 
}
// =======================================================================================================


/**
 * These are all the available tokens in formula engine
 */
< DEFAULT, SUBSCRIPT >
TOKEN :
{
  	// misc tokens
	< EOS : ";" >								:	DEFAULT // End of Statement
| 	< OParen : "(" >							: 	DEFAULT
| 	< CParen : ")" >							: 	SUBSCRIPT // the next open [ means, that this is a subscript
| 	< Assign : ":=" >							:	DEFAULT


	// Keywords
| 	< KW_DEFAULT	: "DEFAULT" >
| 	< KW_ENVIRONMENT: "ENVIRONMENT" >
| 	< KW_FIELD 		: "FIELD" >
| 	< KW_REM 		: "REM" >
| 	< KW_SELECT		: "SELECT" >


// special extension by FOCONIS to define / include custom functions. Should not affect other formulas
| 	< At_Include	: "@Include" >
| 	< At_Function	: "@Function" >

	// @Functions
| 	< At_do			: "@do" > 
| 	< At_doWhile	: "@doWhile" >
| 	< At_while		: "@while" >
| 	< At_for		: "@for" > 
| 	< At_if			: "@if" >
| 	< At_v2if		: "@V2if" >
| 	< At_iferror	: "@iferror" > 
| 	< At_transform	: "@transform" > 
| 	< At_sort		: "@sort" >
| 	< At_text		: "@text" >
| 	< At_eval		: "@eval" >
| 	< At_evalex		: "@evalex" >
| 	< At_foceval	: "@foceval" >
| 	< At_return		: "@return" >
| 	< At_iserror	: "@iserror" >
| 	< At_isavailable: "@isavailable" >  
| 	< At_isunavailable: "@isunavailable" >

	// All other at functions that does not control program flow
| 	< At_other 	: "@" ( < Letter >  )  (  < Letter >  | < Digit > )*  > : SUBSCRIPT // switch to subscript, to handle @dbname[2]


	// Precedence 2
| 	< ListConcat : ":" > : DEFAULT

	// Precedence 3 (= signs, not listed here)
	// < OpPlus : "+" >
	// < OpMinus : "-" >		

	// Precedence 4
| 	< OpMul : "*" >		: DEFAULT 
| 	< OpMulP : "**" >	: DEFAULT 
| 	< OpDiv : "/" >		: DEFAULT 
| 	< OpDivP : "*/" >	: DEFAULT 

	// Precedence 5
| 	< OpPlus : "+" > 	: DEFAULT
| 	< OpPlusP : "*+" > 	: DEFAULT
| 	< OpMinus : "-" > 	: DEFAULT
| 	< OpMinusP : "*-" > : DEFAULT

	// Precedence 6 - all compare operations
|   < CmpEqual : "=" >						: DEFAULT
| 	< CmpEqualP : "*=" >					: DEFAULT
| 	< CmpNE : "<>" | "!=" | "=!" | "><" >	: DEFAULT
| 	< CmpNEP : "*<>" >						: DEFAULT
| 	< CmpLT : "<" >							: DEFAULT
| 	< CmpLTP : "*<" >						: DEFAULT
| 	< CmpGT : ">" >							: DEFAULT
| 	< CmpGTP : "*>" >						: DEFAULT
| 	< CmpLTE : "<=" >						: DEFAULT
| 	< CmpLTEP : "*<=" >						: DEFAULT
| 	< CmpGTE : ">=" >						: DEFAULT
| 	< CmpGTEP : "*>=" >						: DEFAULT

	// Precedence 6a - Not
| 	< BoolNot : "!" >						: DEFAULT

	// Precedence 7
| 	< BoolAnd : "&" > : DEFAULT
| 	< BoolOr : "|" > : DEFAULT
| 	< END_FORMULA : "!>" > : FOCONIS
	// Numbers: TODO: Why are they locale dependent???
	// Thousands separator must be avoided!
|	< NumDoubleUS 	:	(< Digit >)* "." (< Digit >)+ (< Exponent >)? > : SUBSCRIPT 
| 	< NumDoubleDE 	:	(< Digit >)* "," (< Digit >)+ (< Exponent >)? > : SUBSCRIPT 
| 	< NumInteger 	: 	(< Digit >)+ ("."|",")? (< Exponent >)? > : SUBSCRIPT 
| 	< #Exponent: ["e","E"] (["+","-"])? (< Digit >)+ >

	// Strings
| 	< String1 : "\""		 	// Start at "
        	(~["\""] 			// until " or \ 
        	| "\\\""				// but not \ (escaped)
        	 )*  "\"" > : SUBSCRIPT			// end at "
        	 
| 	< String2 : "{"		 		// Start at {
          	(~["}"])*			// until  }
          	"}" >  : SUBSCRIPT	// end at "

| 	< Identifier :  ( < Letter >  )  (  < Letter >  | < Digit > | "." )* > : SUBSCRIPT

// Common groups
| < #Letter:
      [
       "$",			// $
       "A"-"Z",	// A-Z
       "_",			// _
       "a"-"z",	// a-z
       "~",			// ~
       "\u00c0"-"\u00d6",	// \u00c3\u20ac - \u00c3\u2013
       "\u00d8"-"\u00f6",	// \u00c3\u02dc - \u00c3\u00b6
       "\u00f8"-"\u00ff",	// \u00c3\u00b8 - \u00c3\u00bf
       "\u0100"-"\u1fff",	// Latin Extended - A
       "\u3040"-"\u318f",	// HIRAGANA/KATAKANA LETTER
       "\u3300"-"\u337f",	// CJK Compatibility
       "\u3400"-"\u3d2d",	// CJK Unified ideograps Extension A
       "\u4e00"-"\u9fff",	// CJK Unified ideograps Extension A
       "\uf900"-"\ufaff"	// CJK ... other
      ]
  >
|
  < #Digit:
      [
       "0"-"9"
// 	RPr/JSt: only arabic digits are supported       
//       "\u0660"-"\u0669",
//       "\u06f0"-"\u06f9",
//       "\u0966"-"\u096f",
//       "\u09e6"-"\u09ef",
//       "\u0a66"-"\u0a6f",
//       "\u0ae6"-"\u0aef",
//       "\u0b66"-"\u0b6f",
//       "\u0be7"-"\u0bef",
//       "\u0c66"-"\u0c6f",
//       "\u0ce6"-"\u0cef",
//       "\u0d66"-"\u0d6f",
//       "\u0e50"-"\u0e59",
//       "\u0ed0"-"\u0ed9",
//       "\u1040"-"\u1049"
      ]
  >
}
  
/*****************************************************************************************************
 * Here the parser begins. There are two different entry points
 * - parseFormula
 * - parseFocFormula
 *****************************************************************************************************/


/**
 * parses a normal expressions. Expressions must not end with ";" (=< EOS >)
 */
public SimpleNode parseFormula()       :
{/*@bgen(jjtree) AtDo */
  ASTAtDo jjtn000 = new ASTAtDo(this, JJTATDO);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} 
{/*@bgen(jjtree) AtDo */
        try {
/*@egen*/
	mainStatement() ((< EOS >) mainStatement()	)*	< EOF >/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
  	{	jjtn000.setVirtual(true);
  	  	return jjtn000;
  	}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/**
 * A main statement is available on the top level only (cannot be used in @do for example)
 * Only main statements can contain REM comments
 */
public void mainStatement() :
{}
{
	(< EOS >)*
	(	 	< KW_REM > comment()  // AFAIK REMS are only allowed at top level
	|	statement()
	)
}

/**
 * needed for REM
 */
private void comment() :
{}
{
		< String1 >
	| 	< String2 >
	|  	< OParen > comment() < CParen >
}

/**
 * this is the entry point to parse a FOCONIS Formula
 */
public SimpleNode parseFocFormula()           :
{/*@bgen(jjtree) AtConCat */
  ASTAtConCat jjtn000 = new ASTAtConCat(this, JJTATCONCAT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} 
{/*@bgen(jjtree) AtConCat */
        try {
/*@egen*/
 	{ token_source.SwitchTo(FOCONIS); } // TODO RPr can this be done in the init block?
  	(
		focNormalText()
	|	focFormula()
	|	focParam()		
	)*
	< EOF >/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
  	{ return jjtn000; }/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/**
 * a focFormula starts with '<!' and ends with '!>' Everything between is treated as normal formula
 */
private void focFormula() :
{}
{
  	< BEGIN_FORMULA >/*@bgen(jjtree) AtDo */
                {
                  ASTAtDo jjtn001 = new ASTAtDo(this, JJTATDO);
                  boolean jjtc001 = true;
                  jjtree.openNodeScope(jjtn001);
                }
                try {
/*@egen*/
		( mainStatement() ((< EOS >) mainStatement()	)*/*@bgen(jjtree)*/
                                                                   {
                                                                     jjtree.closeNodeScope(jjtn001, true);
                                                                     jjtc001 = false;
                                                                   }
/*@egen*/ {jjtn001.setVirtual(true);} )/*@bgen(jjtree)*/
                } catch (Throwable jjte001) {
                  if (jjtc001) {
                    jjtree.clearNodeScope(jjtn001);
                    jjtc001 = false;
                  } else {
                    jjtree.popNode();
                  }
                  if (jjte001 instanceof RuntimeException) {
                    throw (RuntimeException)jjte001;
                  }
                  if (jjte001 instanceof ParseException) {
                    throw (ParseException)jjte001;
                  }
                  throw (Error)jjte001;
                } finally {
                  if (jjtc001) {
                    jjtree.closeNodeScope(jjtn001, true);
                  }
                }
/*@egen*/      
	< END_FORMULA >
}

/**
 * a focParam starts with '<#' and ends with '#>' Everything between is passed to the parameter resolver
 */

private void focParam()           :
{/*@bgen(jjtree) FocParam */
  ASTFocParam jjtn000 = new ASTFocParam(this, JJTFOCPARAM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t;}
{/*@bgen(jjtree) FocParam */
        try {
/*@egen*/
  	(< BEGIN_PARAM >  t = <PARAM_VALUE >	< END_PARAM > )/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
  	{jjtn000.init(t.image); }/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/**
 * NormalText exists only in FOCONIS state and is outside of focFormula and focParam
 */
private void focNormalText()                :
{/*@bgen(jjtree) FocNormalText */
  ASTFocNormalText jjtn000 = new ASTFocNormalText(this, JJTFOCNORMALTEXT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) FocNormalText */
        try {
/*@egen*/
  	t = < NORMAL_TEXT >/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
  	{jjtn000.init(t.image); }/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}



/**
 * an expression is one of the 3 "set" keywords (DEFAULT/FIELD/ENVIRONMENT) to set Fields/Env
 * or an identifier to set a variable. Special case for SELECT 
 */ 
private void statement() :
{ Token t; }
{
 	// Include is a custom extension by foconis
 	< At_Include >/*@bgen(jjtree) UserDefinedInclude */
                                {
                                  ASTUserDefinedInclude jjtn001 = new ASTUserDefinedInclude(this, JJTUSERDEFINEDINCLUDE);
                                  boolean jjtc001 = true;
                                  jjtree.openNodeScope(jjtn001);
                                }
                                try {
/*@egen*/		(opBool()/*@bgen(jjtree)*/
                                                {
                                                  jjtree.closeNodeScope(jjtn001, true);
                                                  jjtc001 = false;
                                                }
/*@egen*/	{jjtn001.init();} )/*@bgen(jjtree)*/
                                } catch (Throwable jjte001) {
                                  if (jjtc001) {
                                    jjtree.clearNodeScope(jjtn001);
                                    jjtc001 = false;
                                  } else {
                                    jjtree.popNode();
                                  }
                                  if (jjte001 instanceof RuntimeException) {
                                    throw (RuntimeException)jjte001;
                                  }
                                  if (jjte001 instanceof ParseException) {
                                    throw (ParseException)jjte001;
                                  }
                                  throw (Error)jjte001;
                                } finally {
                                  if (jjtc001) {
                                    jjtree.closeNodeScope(jjtn001, true);
                                  }
                                }
/*@egen*/                    

	// At_Function is a custom extension by foconis 	
| 	< At_Function >/*@bgen(jjtree) UserDefinedFunction */
                                {
                                  ASTUserDefinedFunction jjtn002 = new ASTUserDefinedFunction(this, JJTUSERDEFINEDFUNCTION);
                                  boolean jjtc002 = true;
                                  jjtree.openNodeScope(jjtn002);
                                }
                                try {
/*@egen*/		(< OParen >		// @function(@myfunc(a:="x";b:="y");"";
							exFuncDef()	(< EOS > exVar())* // followed by optional semicolon and local var defs
						< CParen >

							( < Assign >  opBool() )?/*@bgen(jjtree)*/
                                                {
                                                  jjtree.closeNodeScope(jjtn002, true);
                                                  jjtc002 = false;
                                                }
/*@egen*/	 // Assignment is optional
						{jjtn002.init();}
						)/*@bgen(jjtree)*/
                                } catch (Throwable jjte002) {
                                  if (jjtc002) {
                                    jjtree.clearNodeScope(jjtn002);
                                    jjtc002 = false;
                                  } else {
                                    jjtree.popNode();
                                  }
                                  if (jjte002 instanceof RuntimeException) {
                                    throw (RuntimeException)jjte002;
                                  }
                                  if (jjte002 instanceof ParseException) {
                                    throw (ParseException)jjte002;
                                  }
                                  throw (Error)jjte002;
                                } finally {
                                  if (jjtc002) {
                                    jjtree.closeNodeScope(jjtn002, true);
                                  }
                                }
/*@egen*/                     
|  	< KW_FIELD >/*@bgen(jjtree) Assignment */
                                {
                                  ASTAssignment jjtn003 = new ASTAssignment(this, JJTASSIGNMENT);
                                  boolean jjtc003 = true;
                                  jjtree.openNodeScope(jjtn003);
                                }
                                try {
/*@egen*/ 		(t = < Identifier > < Assign > {jjtn003.init(t.image, ASTAssignment.FIELD);		} opBool())/*@bgen(jjtree)*/
                                } catch (Throwable jjte003) {
                                  if (jjtc003) {
                                    jjtree.clearNodeScope(jjtn003);
                                    jjtc003 = false;
                                  } else {
                                    jjtree.popNode();
                                  }
                                  if (jjte003 instanceof RuntimeException) {
                                    throw (RuntimeException)jjte003;
                                  }
                                  if (jjte003 instanceof ParseException) {
                                    throw (ParseException)jjte003;
                                  }
                                  throw (Error)jjte003;
                                } finally {
                                  if (jjtc003) {
                                    jjtree.closeNodeScope(jjtn003, true);
                                  }
                                }
/*@egen*/ 	           
|  	LOOKAHEAD(2)/*@bgen(jjtree) Assignment */
                                {
                                  ASTAssignment jjtn004 = new ASTAssignment(this, JJTASSIGNMENT);
                                  boolean jjtc004 = true;
                                  jjtree.openNodeScope(jjtn004);
                                }
                                try {
/*@egen*/ 		(t = < Identifier > < Assign > {jjtn004.init(t.image, ASTAssignment.VAR);		} opBool())/*@bgen(jjtree)*/
                                } catch (Throwable jjte004) {
                                  if (jjtc004) {
                                    jjtree.clearNodeScope(jjtn004);
                                    jjtc004 = false;
                                  } else {
                                    jjtree.popNode();
                                  }
                                  if (jjte004 instanceof RuntimeException) {
                                    throw (RuntimeException)jjte004;
                                  }
                                  if (jjte004 instanceof ParseException) {
                                    throw (ParseException)jjte004;
                                  }
                                  throw (Error)jjte004;
                                } finally {
                                  if (jjtc004) {
                                    jjtree.closeNodeScope(jjtn004, true);
                                  }
                                }
/*@egen*/ 	           
| 	< KW_ENVIRONMENT >/*@bgen(jjtree) Assignment */
                                {
                                  ASTAssignment jjtn005 = new ASTAssignment(this, JJTASSIGNMENT);
                                  boolean jjtc005 = true;
                                  jjtree.openNodeScope(jjtn005);
                                }
                                try {
/*@egen*/ 	(t = < Identifier > < Assign > {jjtn005.init(t.image, ASTAssignment.ENV);		} opBool())/*@bgen(jjtree)*/
                                } catch (Throwable jjte005) {
                                  if (jjtc005) {
                                    jjtree.clearNodeScope(jjtn005);
                                    jjtc005 = false;
                                  } else {
                                    jjtree.popNode();
                                  }
                                  if (jjte005 instanceof RuntimeException) {
                                    throw (RuntimeException)jjte005;
                                  }
                                  if (jjte005 instanceof ParseException) {
                                    throw (ParseException)jjte005;
                                  }
                                  throw (Error)jjte005;
                                } finally {
                                  if (jjtc005) {
                                    jjtree.closeNodeScope(jjtn005, true);
                                  }
                                }
/*@egen*/ 	           
| 	< KW_DEFAULT >/*@bgen(jjtree) Assignment */
                                {
                                  ASTAssignment jjtn006 = new ASTAssignment(this, JJTASSIGNMENT);
                                  boolean jjtc006 = true;
                                  jjtree.openNodeScope(jjtn006);
                                }
                                try {
/*@egen*/ 		(t = < Identifier > < Assign > {jjtn006.init(t.image, ASTAssignment.DEFAULT);	} opBool())/*@bgen(jjtree)*/
                                } catch (Throwable jjte006) {
                                  if (jjtc006) {
                                    jjtree.clearNodeScope(jjtn006);
                                    jjtc006 = false;
                                  } else {
                                    jjtree.popNode();
                                  }
                                  if (jjte006 instanceof RuntimeException) {
                                    throw (RuntimeException)jjte006;
                                  }
                                  if (jjte006 instanceof ParseException) {
                                    throw (ParseException)jjte006;
                                  }
                                  throw (Error)jjte006;
                                } finally {
                                  if (jjtc006) {
                                    jjtree.closeNodeScope(jjtn006, true);
                                  }
                                }
/*@egen*/ 	           
| 	< KW_SELECT >/*@bgen(jjtree) Select */
                      {
                        ASTSelect jjtn007 = new ASTSelect(this, JJTSELECT);
                        boolean jjtc007 = true;
                        jjtree.openNodeScope(jjtn007);
                      }
                      try {
/*@egen*/ opBool()/*@bgen(jjtree)*/
                      } catch (Throwable jjte007) {
                        if (jjtc007) {
                          jjtree.clearNodeScope(jjtn007);
                          jjtc007 = false;
                        } else {
                          jjtree.popNode();
                        }
                        if (jjte007 instanceof RuntimeException) {
                          throw (RuntimeException)jjte007;
                        }
                        if (jjte007 instanceof ParseException) {
                          throw (ParseException)jjte007;
                        }
                        throw (Error)jjte007;
                      } finally {
                        if (jjtc007) {
                          jjtree.closeNodeScope(jjtn007, true);
                        }
                      }
/*@egen*/ 									       
| 	opBool()
}  

/**
 * Parameter for extended functions
 */
private void exFuncDef()                         :
{/*@bgen(jjtree) UserDefinedFunctionDef */
  ASTUserDefinedFunctionDef jjtn000 = new ASTUserDefinedFunctionDef(this, JJTUSERDEFINEDFUNCTIONDEF);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) UserDefinedFunctionDef */
   try {
/*@egen*/
   // matches to @myfunc(a:="x";b:="y")
   t = < At_other > (< OParen >	exParam() (< EOS > exParam())* < CParen >)?/*@bgen(jjtree)*/
   {
     jjtree.closeNodeScope(jjtn000, true);
     jjtc000 = false;
   }
/*@egen*/
   {jjtn000.init(t.image);}/*@bgen(jjtree)*/
   } catch (Throwable jjte000) {
     if (jjtc000) {
       jjtree.clearNodeScope(jjtn000);
       jjtc000 = false;
     } else {
       jjtree.popNode();
     }
     if (jjte000 instanceof RuntimeException) {
       throw (RuntimeException)jjte000;
     }
     if (jjte000 instanceof ParseException) {
       throw (ParseException)jjte000;
     }
     throw (Error)jjte000;
   } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
     }
   }
/*@egen*/
}

/**
 * Parameter for extended functions
 */
private void exParam()                               :
{/*@bgen(jjtree) UserDefinedFunctionParameter */
  ASTUserDefinedFunctionParameter jjtn000 = new ASTUserDefinedFunctionParameter(this, JJTUSERDEFINEDFUNCTIONPARAMETER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) UserDefinedFunctionParameter */
  try {
/*@egen*/
  (
 	LOOKAHEAD(2)  t = < Identifier > 	< Assign > opBool()    
| 	t = < Identifier > 	

)/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/ {jjtn000.init(t.image);}/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}  

/**
 * Parameter for extended functions
 */
private void exVar()                              :
{/*@bgen(jjtree) UserDefinedFunctionVariable */
  ASTUserDefinedFunctionVariable jjtn000 = new ASTUserDefinedFunctionVariable(this, JJTUSERDEFINEDFUNCTIONVARIABLE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) UserDefinedFunctionVariable */
  try {
/*@egen*/
  (
 	LOOKAHEAD(2)  t = < Identifier > 	< Assign > opBool()    
| 	t = < Identifier > 	

)/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/ {jjtn000.init(t.image);}/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}  
  
/**
 * boolean operators have the lowest precedence,
 * ATTENTION: Formula language is the only language I know, where AND and OR has the same precedence!
 */
private void opBool() :
{ }
{
  opNot() (/*@bgen(jjtree) #Operator( 2) */
    {
      ASTOperator jjtn001 = new ASTOperator(this, JJTOPERATOR);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
    }
    try {
/*@egen*/
    (
    		< BoolAnd > opNot()/*@bgen(jjtree)*/
                                    {
                                      jjtree.closeNodeScope(jjtn001,  2);
                                      jjtc001 = false;
                                    }
/*@egen*/ {jjtn001.init("&");	}
    	| 	< BoolOr >  opNot()/*@bgen(jjtree)*/
                                    {
                                      jjtree.closeNodeScope(jjtn001,  2);
                                      jjtc001 = false;
                                    }
/*@egen*/ {jjtn001.init("|");	}  	
  	)/*@bgen(jjtree)*/
    } catch (Throwable jjte001) {
      if (jjtc001) {
        jjtree.clearNodeScope(jjtn001);
        jjtc001 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte001 instanceof RuntimeException) {
        throw (RuntimeException)jjte001;
      }
      if (jjte001 instanceof ParseException) {
        throw (ParseException)jjte001;
      }
      throw (Error)jjte001;
    } finally {
      if (jjtc001) {
        jjtree.closeNodeScope(jjtn001,  2);
      }
    }
/*@egen*/             
  )*
}

/**
 * "Not" needs special care, because expressions like !!!!!1=1 are allowed
 */
private void opNot() :
{ }
{
	opHasNot()
|	opCmp()
}

private void opHasNot() :
{}
{
  	< BoolNot > opNot()/*@bgen(jjtree) #Operator( 1) */
                            {
                              ASTOperator jjtn001 = new ASTOperator(this, JJTOPERATOR);
                              boolean jjtc001 = true;
                              jjtree.openNodeScope(jjtn001);
                            }
                            try {
/*@egen*//*@bgen(jjtree)*/
                            {
                              jjtree.closeNodeScope(jjtn001,  1);
                              jjtc001 = false;
                            }
/*@egen*/ {jjtn001.init(" !")	;}/*@bgen(jjtree)*/
                            } finally {
                              if (jjtc001) {
                                jjtree.closeNodeScope(jjtn001,  1);
                              }
                            }
/*@egen*/             
}

/**
 * before boolean, all compares are evaluated
 */
private void opCmp()  :
{ }
{
  opAdd()  (/*@bgen(jjtree) #Operator( 2) */
    {
      ASTOperator jjtn001 = new ASTOperator(this, JJTOPERATOR);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
    }
    try {
/*@egen*/
    (
     		< CmpEqual > 	opAdd()/*@bgen(jjtree)*/
                                        {
                                          jjtree.closeNodeScope(jjtn001,  2);
                                          jjtc001 = false;
                                        }
/*@egen*/ {jjtn001.init("=")		;}
    	| 	< CmpEqualP > 	opAdd()/*@bgen(jjtree)*/
                                        {
                                          jjtree.closeNodeScope(jjtn001,  2);
                                          jjtc001 = false;
                                        }
/*@egen*/ {jjtn001.init("*=")		;}
     	| 	< CmpNE > 		opAdd()/*@bgen(jjtree)*/
                                                {
                                                  jjtree.closeNodeScope(jjtn001,  2);
                                                  jjtc001 = false;
                                                }
/*@egen*/ {jjtn001.init("<>")		;}
     	| 	< CmpNEP > 		opAdd()/*@bgen(jjtree)*/
                                                {
                                                  jjtree.closeNodeScope(jjtn001,  2);
                                                  jjtc001 = false;
                                                }
/*@egen*/ {jjtn001.init("*<>")	;}
     	| 	< CmpLT > 		opAdd()/*@bgen(jjtree)*/
                                                {
                                                  jjtree.closeNodeScope(jjtn001,  2);
                                                  jjtc001 = false;
                                                }
/*@egen*/ {jjtn001.init("<")		;}
     	| 	< CmpLTP > 		opAdd()/*@bgen(jjtree)*/
                                                {
                                                  jjtree.closeNodeScope(jjtn001,  2);
                                                  jjtc001 = false;
                                                }
/*@egen*/ {jjtn001.init("*<")		;}
    	| 	< CmpGT > 		opAdd()/*@bgen(jjtree)*/
                                                {
                                                  jjtree.closeNodeScope(jjtn001,  2);
                                                  jjtc001 = false;
                                                }
/*@egen*/ {jjtn001.init(">")		;}
     	| 	< CmpGTP > 		opAdd()/*@bgen(jjtree)*/
                                                {
                                                  jjtree.closeNodeScope(jjtn001,  2);
                                                  jjtc001 = false;
                                                }
/*@egen*/ {jjtn001.init("*>")		;}
     	| 	< CmpLTE > 		opAdd()/*@bgen(jjtree)*/
                                                {
                                                  jjtree.closeNodeScope(jjtn001,  2);
                                                  jjtc001 = false;
                                                }
/*@egen*/ {jjtn001.init("<=")		;}
     	| 	< CmpLTEP > 	opAdd()/*@bgen(jjtree)*/
                                        {
                                          jjtree.closeNodeScope(jjtn001,  2);
                                          jjtc001 = false;
                                        }
/*@egen*/ {jjtn001.init("*<=")	;}
     	| 	< CmpGTE > 		opAdd()/*@bgen(jjtree)*/
                                                {
                                                  jjtree.closeNodeScope(jjtn001,  2);
                                                  jjtc001 = false;
                                                }
/*@egen*/ {jjtn001.init(">=")		;}
     	| 	< CmpGTEP > 	opAdd()/*@bgen(jjtree)*/
                                        {
                                          jjtree.closeNodeScope(jjtn001,  2);
                                          jjtc001 = false;
                                        }
/*@egen*/ {jjtn001.init("*>=")	;}
    )/*@bgen(jjtree)*/
    } catch (Throwable jjte001) {
      if (jjtc001) {
        jjtree.clearNodeScope(jjtn001);
        jjtc001 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte001 instanceof RuntimeException) {
        throw (RuntimeException)jjte001;
      }
      if (jjte001 instanceof ParseException) {
        throw (ParseException)jjte001;
      }
      throw (Error)jjte001;
    } finally {
      if (jjtc001) {
        jjtree.closeNodeScope(jjtn001,  2);
      }
    }
/*@egen*/             )*
}


/**
 * next precedence are all add/subtract operations
 */
private void opAdd() :
{ }
{
  
  opMult()  (LOOKAHEAD(2)/*@bgen(jjtree) #Operator( 2) */
                          {
                            ASTOperator jjtn001 = new ASTOperator(this, JJTOPERATOR);
                            boolean jjtc001 = true;
                            jjtree.openNodeScope(jjtn001);
                          }
                          try {
/*@egen*/ ( // lookahead 2 is required, to determine if it is a sign 
			< OpPlus >	 	opMult()/*@bgen(jjtree)*/
                                                         {
                                                           jjtree.closeNodeScope(jjtn001,  2);
                                                           jjtc001 = false;
                                                         }
/*@egen*/ {jjtn001.init("+")		;} 
		| 	< OpPlusP >		opMult()/*@bgen(jjtree)*/
                                                         {
                                                           jjtree.closeNodeScope(jjtn001,  2);
                                                           jjtc001 = false;
                                                         }
/*@egen*/ {jjtn001.init("*+")	;} 
		| 	< OpMinus > 	opMult()/*@bgen(jjtree)*/
                                                 {
                                                   jjtree.closeNodeScope(jjtn001,  2);
                                                   jjtc001 = false;
                                                 }
/*@egen*/ {jjtn001.init("-")		;} 
		| 	< OpMinusP > 	opMult()/*@bgen(jjtree)*/
                                                 {
                                                   jjtree.closeNodeScope(jjtn001,  2);
                                                   jjtc001 = false;
                                                 }
/*@egen*/ {jjtn001.init("*-")	;} 
	)/*@bgen(jjtree)*/
                          } catch (Throwable jjte001) {
                            if (jjtc001) {
                              jjtree.clearNodeScope(jjtn001);
                              jjtc001 = false;
                            } else {
                              jjtree.popNode();
                            }
                            if (jjte001 instanceof RuntimeException) {
                              throw (RuntimeException)jjte001;
                            }
                            if (jjte001 instanceof ParseException) {
                              throw (ParseException)jjte001;
                            }
                            throw (Error)jjte001;
                          } finally {
                            if (jjtc001) {
                              jjtree.closeNodeScope(jjtn001,  2);
                            }
                          }
/*@egen*/               )*
}

/**
 * highest precedence of operations is multiplication. This is done with a unary list
 */
private void opMult()  :
{ }
{
  opSign()  (/*@bgen(jjtree) #Operator( 2) */
    {
      ASTOperator jjtn001 = new ASTOperator(this, JJTOPERATOR);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
    }
    try {
/*@egen*/
    (
      		< OpMul > 	opSign()/*@bgen(jjtree)*/
                                          {
                                            jjtree.closeNodeScope(jjtn001,  2);
                                            jjtc001 = false;
                                          }
/*@egen*/  {jjtn001.init("*")	;}
     	|	< OpMulP > 	opSign()/*@bgen(jjtree)*/
                                          {
                                            jjtree.closeNodeScope(jjtn001,  2);
                                            jjtc001 = false;
                                          }
/*@egen*/  {jjtn001.init("**")	;}
      	| 	< OpDiv > 	opSign()/*@bgen(jjtree)*/
                                          {
                                            jjtree.closeNodeScope(jjtn001,  2);
                                            jjtc001 = false;
                                          }
/*@egen*/  {jjtn001.init("/")	;}
      	| 	< OpDivP > 	opSign()/*@bgen(jjtree)*/
                                          {
                                            jjtree.closeNodeScope(jjtn001,  2);
                                            jjtc001 = false;
                                          }
/*@egen*/  {jjtn001.init("*/")	;}
	)/*@bgen(jjtree)*/
    } catch (Throwable jjte001) {
      if (jjtc001) {
        jjtree.clearNodeScope(jjtn001);
        jjtc001 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte001 instanceof RuntimeException) {
        throw (RuntimeException)jjte001;
      }
      if (jjte001 instanceof ParseException) {
        throw (ParseException)jjte001;
      }
      throw (Error)jjte001;
    } finally {
      if (jjtc001) {
        jjtree.closeNodeScope(jjtn001,  2);
      }
    }
/*@egen*/              ) *
}

private void opSign() :
{ }
{

	opHasSign()
|	valueList()
}

private void opHasSign() :
{}
{
// In N9, the + sign is completely ignored. If you want to be < N6 compatible, feel free to implement that  
//	< OpPlus > valueList() {jjtThis.init(" +")	;} #Operator(1)
	< OpPlus > opSign()
| 	< OpMinus > opSign()/*@bgen(jjtree) #Operator( 1) */
                             {
                               ASTOperator jjtn001 = new ASTOperator(this, JJTOPERATOR);
                               boolean jjtc001 = true;
                               jjtree.openNodeScope(jjtn001);
                             }
                             try {
/*@egen*//*@bgen(jjtree)*/
                             {
                               jjtree.closeNodeScope(jjtn001,  1);
                               jjtc001 = false;
                             }
/*@egen*/ {jjtn001.init(" -")	;}/*@bgen(jjtree)*/
                             } finally {
                               if (jjtc001) {
                                 jjtree.closeNodeScope(jjtn001,  1);
                               }
                             }
/*@egen*/             
}
/**
 * one ore more values
 * for saving mem, unaries are wrapped only in a valueList, if there are more than once
 */
private void valueList() :
{}
{/*@bgen(jjtree) #ValueList(> 1) */
        {
          ASTValueList jjtn001 = new ASTValueList(this, JJTVALUELIST);
          boolean jjtc001 = true;
          jjtree.openNodeScope(jjtn001);
        }
        try {
/*@egen*/
	(subscript() (
	  		LOOKAHEAD(2)
	  		< ListConcat > (opHasSign()| subscript() )
	)* )/*@bgen(jjtree)*/
        } catch (Throwable jjte001) {
          if (jjtc001) {
            jjtree.clearNodeScope(jjtn001);
            jjtc001 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte001 instanceof RuntimeException) {
            throw (RuntimeException)jjte001;
          }
          if (jjte001 instanceof ParseException) {
            throw (ParseException)jjte001;
          }
          throw (Error)jjte001;
        } finally {
          if (jjtc001) {
            jjtree.closeNodeScope(jjtn001, jjtree.nodeArity() > 1);
          }
        }
/*@egen*/                 
}

/**
 * Subscript to access a element in a list
 */
private void subscript() :
{}
{/*@bgen(jjtree) #Subscript(> 1) */
        {
          ASTSubscript jjtn001 = new ASTSubscript(this, JJTSUBSCRIPT);
          boolean jjtc001 = true;
          jjtree.openNodeScope(jjtn001);
        }
        try {
/*@egen*/
  	(unary()  (< OSubscript > statement() < CSubscript >)*)/*@bgen(jjtree)*/
        } catch (Throwable jjte001) {
          if (jjtc001) {
            jjtree.clearNodeScope(jjtn001);
            jjtc001 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte001 instanceof RuntimeException) {
            throw (RuntimeException)jjte001;
          }
          if (jjte001 instanceof ParseException) {
            throw (ParseException)jjte001;
          }
          throw (Error)jjte001;
        } finally {
          if (jjtc001) {
            jjtree.closeNodeScope(jjtn001, jjtree.nodeArity() > 1);
          }
        }
/*@egen*/               
}

/**
 * a unary operation
 */
private void unary() :
{}
{

// Attention List operator has a higher precedence. So this is removed here 
// 		< OpPlus > unary() 
//| 	< OpMinus > unary() {jjtThis.init(" -")	;} #Operator(1)
//|

// All control flow functions
  < At_do >/*@bgen(jjtree) AtDo */
                        {
                          ASTAtDo jjtn001 = new ASTAtDo(this, JJTATDO);
                          boolean jjtc001 = true;
                          jjtree.openNodeScope(jjtn001);
                        }
                        try {
/*@egen*/ 		(< OParen >  statement() ( < EOS > statement() )*  < CParen >)/*@bgen(jjtree)*/
                        } catch (Throwable jjte001) {
                          if (jjtc001) {
                            jjtree.clearNodeScope(jjtn001);
                            jjtc001 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte001 instanceof RuntimeException) {
                            throw (RuntimeException)jjte001;
                          }
                          if (jjte001 instanceof ParseException) {
                            throw (ParseException)jjte001;
                          }
                          throw (Error)jjte001;
                        } finally {
                          if (jjtc001) {
                            jjtree.closeNodeScope(jjtn001, true);
                          }
                        }
/*@egen*/      
| < At_doWhile >/*@bgen(jjtree) AtDoWhile */
                        {
                          ASTAtDoWhile jjtn002 = new ASTAtDoWhile(this, JJTATDOWHILE);
                          boolean jjtc002 = true;
                          jjtree.openNodeScope(jjtn002);
                        }
                        try {
/*@egen*/ 	(< OParen >  statement() ( < EOS > statement() )*  < CParen >)/*@bgen(jjtree)*/
                        } catch (Throwable jjte002) {
                          if (jjtc002) {
                            jjtree.clearNodeScope(jjtn002);
                            jjtc002 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte002 instanceof RuntimeException) {
                            throw (RuntimeException)jjte002;
                          }
                          if (jjte002 instanceof ParseException) {
                            throw (ParseException)jjte002;
                          }
                          throw (Error)jjte002;
                        } finally {
                          if (jjtc002) {
                            jjtree.closeNodeScope(jjtn002, true);
                          }
                        }
/*@egen*/           
| < At_while >/*@bgen(jjtree) AtWhile */
                        {
                          ASTAtWhile jjtn003 = new ASTAtWhile(this, JJTATWHILE);
                          boolean jjtc003 = true;
                          jjtree.openNodeScope(jjtn003);
                        }
                        try {
/*@egen*/ 		(< OParen >  statement() ( < EOS > statement() )*  < CParen >)/*@bgen(jjtree)*/
                        } catch (Throwable jjte003) {
                          if (jjtc003) {
                            jjtree.clearNodeScope(jjtn003);
                            jjtc003 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte003 instanceof RuntimeException) {
                            throw (RuntimeException)jjte003;
                          }
                          if (jjte003 instanceof ParseException) {
                            throw (ParseException)jjte003;
                          }
                          throw (Error)jjte003;
                        } finally {
                          if (jjtc003) {
                            jjtree.closeNodeScope(jjtn003, true);
                          }
                        }
/*@egen*/         

| < At_for >/*@bgen(jjtree) AtFor */
                        {
                          ASTAtFor jjtn004 = new ASTAtFor(this, JJTATFOR);
                          boolean jjtc004 = true;
                          jjtree.openNodeScope(jjtn004);
                        }
                        try {
/*@egen*/		(< OParen >  	statement()	// initialize
						< EOS >		statement()	// condition
						< EOS >		statement() 	// increment
						( < EOS > 	statement() )*	// statements
					 < CParen >)/*@bgen(jjtree)*/
                        } catch (Throwable jjte004) {
                          if (jjtc004) {
                            jjtree.clearNodeScope(jjtn004);
                            jjtc004 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte004 instanceof RuntimeException) {
                            throw (RuntimeException)jjte004;
                          }
                          if (jjte004 instanceof ParseException) {
                            throw (ParseException)jjte004;
                          }
                          throw (Error)jjte004;
                        } finally {
                          if (jjtc004) {
                            jjtree.closeNodeScope(jjtn004, true);
                          }
                        }
/*@egen*/       

| (< At_if > | < At_v2if > )/*@bgen(jjtree) AtIf */
                                        {
                                          ASTAtIf jjtn005 = new ASTAtIf(this, JJTATIF);
                                          boolean jjtc005 = true;
                                          jjtree.openNodeScope(jjtn005);
                                        }
                                        try {
/*@egen*/
					(< OParen >  	statement()	// if
						( < EOS > 	statement() < EOS > statement())+	// the elese(if)
					 < CParen >)/*@bgen(jjtree)*/
                                        } catch (Throwable jjte005) {
                                          if (jjtc005) {
                                            jjtree.clearNodeScope(jjtn005);
                                            jjtc005 = false;
                                          } else {
                                            jjtree.popNode();
                                          }
                                          if (jjte005 instanceof RuntimeException) {
                                            throw (RuntimeException)jjte005;
                                          }
                                          if (jjte005 instanceof ParseException) {
                                            throw (ParseException)jjte005;
                                          }
                                          throw (Error)jjte005;
                                        } finally {
                                          if (jjtc005) {
                                            jjtree.closeNodeScope(jjtn005, true);
                                          }
                                        }
/*@egen*/      
					 
| < At_iferror >/*@bgen(jjtree) AtIfError */
                        {
                          ASTAtIfError jjtn006 = new ASTAtIfError(this, JJTATIFERROR);
                          boolean jjtc006 = true;
                          jjtree.openNodeScope(jjtn006);
                        }
                        try {
/*@egen*/	(< OParen >  	statement() (< EOS > statement())? < CParen >)/*@bgen(jjtree)*/
                        } catch (Throwable jjte006) {
                          if (jjtc006) {
                            jjtree.clearNodeScope(jjtn006);
                            jjtc006 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte006 instanceof RuntimeException) {
                            throw (RuntimeException)jjte006;
                          }
                          if (jjte006 instanceof ParseException) {
                            throw (ParseException)jjte006;
                          }
                          throw (Error)jjte006;
                        } finally {
                          if (jjtc006) {
                            jjtree.closeNodeScope(jjtn006, true);
                          }
                        }
/*@egen*/           

| < At_transform >/*@bgen(jjtree) AtTransform */
                        {
                          ASTAtTransform jjtn007 = new ASTAtTransform(this, JJTATTRANSFORM);
                          boolean jjtc007 = true;
                          jjtree.openNodeScope(jjtn007);
                        }
                        try {
/*@egen*/	(< OParen >  	statement()	// list
						< EOS >		statement()	// varName
						< EOS >		statement() 	// formula
					 < CParen >)/*@bgen(jjtree)*/
                        } catch (Throwable jjte007) {
                          if (jjtc007) {
                            jjtree.clearNodeScope(jjtn007);
                            jjtc007 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte007 instanceof RuntimeException) {
                            throw (RuntimeException)jjte007;
                          }
                          if (jjte007 instanceof ParseException) {
                            throw (ParseException)jjte007;
                          }
                          throw (Error)jjte007;
                        } finally {
                          if (jjtc007) {
                            jjtree.closeNodeScope(jjtn007, true);
                          }
                        }
/*@egen*/             
					 
| < At_sort >/*@bgen(jjtree) AtSort */
                        {
                          ASTAtSort jjtn008 = new ASTAtSort(this, JJTATSORT);
                          boolean jjtc008 = true;
                          jjtree.openNodeScope(jjtn008);
                        }
                        try {
/*@egen*/		(< OParen >  	statement()		// list
						(< EOS >	statement()		// Options
							(< EOS >	statement())? 	// formula
						)?
					 < CParen >)/*@bgen(jjtree)*/
                        } catch (Throwable jjte008) {
                          if (jjtc008) {
                            jjtree.clearNodeScope(jjtn008);
                            jjtc008 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte008 instanceof RuntimeException) {
                            throw (RuntimeException)jjte008;
                          }
                          if (jjte008 instanceof ParseException) {
                            throw (ParseException)jjte008;
                          }
                          throw (Error)jjte008;
                        } finally {
                          if (jjtc008) {
                            jjtree.closeNodeScope(jjtn008, true);
                          }
                        }
/*@egen*/        
| < At_eval >/*@bgen(jjtree) AtEval */
                        {
                          ASTAtEval jjtn009 = new ASTAtEval(this, JJTATEVAL);
                          boolean jjtc009 = true;
                          jjtree.openNodeScope(jjtn009);
                        }
                        try {
/*@egen*/		(< OParen >  	statement()		
					 < CParen >)/*@bgen(jjtree)*/
                        } catch (Throwable jjte009) {
                          if (jjtc009) {
                            jjtree.clearNodeScope(jjtn009);
                            jjtc009 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte009 instanceof RuntimeException) {
                            throw (RuntimeException)jjte009;
                          }
                          if (jjte009 instanceof ParseException) {
                            throw (ParseException)jjte009;
                          }
                          throw (Error)jjte009;
                        } finally {
                          if (jjtc009) {
                            jjtree.closeNodeScope(jjtn009, true);
                          }
                        }
/*@egen*/        
| < At_evalex >/*@bgen(jjtree) AtEvalEx */
                        {
                          ASTAtEvalEx jjtn010 = new ASTAtEvalEx(this, JJTATEVALEX);
                          boolean jjtc010 = true;
                          jjtree.openNodeScope(jjtn010);
                        }
                        try {
/*@egen*/		(< OParen >  	statement()		
						( < EOS > 	statement() )*	// parameter
					 < CParen >)/*@bgen(jjtree)*/
                        } catch (Throwable jjte010) {
                          if (jjtc010) {
                            jjtree.clearNodeScope(jjtn010);
                            jjtc010 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte010 instanceof RuntimeException) {
                            throw (RuntimeException)jjte010;
                          }
                          if (jjte010 instanceof ParseException) {
                            throw (ParseException)jjte010;
                          }
                          throw (Error)jjte010;
                        } finally {
                          if (jjtc010) {
                            jjtree.closeNodeScope(jjtn010, true);
                          }
                        }
/*@egen*/          
| < At_foceval >/*@bgen(jjtree) AtFocEval */
                        {
                          ASTAtFocEval jjtn011 = new ASTAtFocEval(this, JJTATFOCEVAL);
                          boolean jjtc011 = true;
                          jjtree.openNodeScope(jjtn011);
                        }
                        try {
/*@egen*/	(< OParen >  	statement()		
					 < CParen >)/*@bgen(jjtree)*/
                        } catch (Throwable jjte011) {
                          if (jjtc011) {
                            jjtree.clearNodeScope(jjtn011);
                            jjtc011 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte011 instanceof RuntimeException) {
                            throw (RuntimeException)jjte011;
                          }
                          if (jjte011 instanceof ParseException) {
                            throw (ParseException)jjte011;
                          }
                          throw (Error)jjte011;
                        } finally {
                          if (jjtc011) {
                            jjtree.closeNodeScope(jjtn011, true);
                          }
                        }
/*@egen*/           
| < At_text >/*@bgen(jjtree) AtText */
                        {
                          ASTAtText jjtn012 = new ASTAtText(this, JJTATTEXT);
                          boolean jjtc012 = true;
                          jjtree.openNodeScope(jjtn012);
                        }
                        try {
/*@egen*/		(< OParen >  	statement()		// list
						(< EOS >	statement())?	// Options
					 < CParen >)/*@bgen(jjtree)*/
                        } catch (Throwable jjte012) {
                          if (jjtc012) {
                            jjtree.clearNodeScope(jjtn012);
                            jjtc012 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte012 instanceof RuntimeException) {
                            throw (RuntimeException)jjte012;
                          }
                          if (jjte012 instanceof ParseException) {
                            throw (ParseException)jjte012;
                          }
                          throw (Error)jjte012;
                        } finally {
                          if (jjtc012) {
                            jjtree.closeNodeScope(jjtn012, true);
                          }
                        }
/*@egen*/        
| < At_return >/*@bgen(jjtree) AtReturn */
                {
                  ASTAtReturn jjtn013 = new ASTAtReturn(this, JJTATRETURN);
                  boolean jjtc013 = true;
                  jjtree.openNodeScope(jjtn013);
                }
                try {
/*@egen*/ (< OParen >  statement() < CParen >)/*@bgen(jjtree)*/
                } catch (Throwable jjte013) {
                  if (jjtc013) {
                    jjtree.clearNodeScope(jjtn013);
                    jjtc013 = false;
                  } else {
                    jjtree.popNode();
                  }
                  if (jjte013 instanceof RuntimeException) {
                    throw (RuntimeException)jjte013;
                  }
                  if (jjte013 instanceof ParseException) {
                    throw (ParseException)jjte013;
                  }
                  throw (Error)jjte013;
                } finally {
                  if (jjtc013) {
                    jjtree.closeNodeScope(jjtn013, true);
                  }
                }
/*@egen*/          
| < At_iserror >/*@bgen(jjtree) AtIsError */
                 {
                   ASTAtIsError jjtn014 = new ASTAtIsError(this, JJTATISERROR);
                   boolean jjtc014 = true;
                   jjtree.openNodeScope(jjtn014);
                 }
                 try {
/*@egen*/ (< OParen >  statement() < CParen >)/*@bgen(jjtree)*/
                 } catch (Throwable jjte014) {
                   if (jjtc014) {
                     jjtree.clearNodeScope(jjtn014);
                     jjtc014 = false;
                   } else {
                     jjtree.popNode();
                   }
                   if (jjte014 instanceof RuntimeException) {
                     throw (RuntimeException)jjte014;
                   }
                   if (jjte014 instanceof ParseException) {
                     throw (ParseException)jjte014;
                   }
                   throw (Error)jjte014;
                 } finally {
                   if (jjtc014) {
                     jjtree.closeNodeScope(jjtn014, true);
                   }
                 }
/*@egen*/            
| < At_isavailable >/*@bgen(jjtree) AtIsAvailable */
                     {
                       ASTAtIsAvailable jjtn015 = new ASTAtIsAvailable(this, JJTATISAVAILABLE);
                       boolean jjtc015 = true;
                       jjtree.openNodeScope(jjtn015);
                     }
                     try {
/*@egen*/ (< OParen >  statement() < CParen >)/*@bgen(jjtree)*/
                     } catch (Throwable jjte015) {
                       if (jjtc015) {
                         jjtree.clearNodeScope(jjtn015);
                         jjtc015 = false;
                       } else {
                         jjtree.popNode();
                       }
                       if (jjte015 instanceof RuntimeException) {
                         throw (RuntimeException)jjte015;
                       }
                       if (jjte015 instanceof ParseException) {
                         throw (ParseException)jjte015;
                       }
                       throw (Error)jjte015;
                     } finally {
                       if (jjtc015) {
                         jjtree.closeNodeScope(jjtn015, true);
                       }
                     }
/*@egen*/                
| < At_isunavailable >/*@bgen(jjtree) AtIsUnavailable */
                       {
                         ASTAtIsUnavailable jjtn016 = new ASTAtIsUnavailable(this, JJTATISUNAVAILABLE);
                         boolean jjtc016 = true;
                         jjtree.openNodeScope(jjtn016);
                       }
                       try {
/*@egen*/ (< OParen >  statement() < CParen >)/*@bgen(jjtree)*/
                       } catch (Throwable jjte016) {
                         if (jjtc016) {
                           jjtree.clearNodeScope(jjtn016);
                           jjtc016 = false;
                         } else {
                           jjtree.popNode();
                         }
                         if (jjte016 instanceof RuntimeException) {
                           throw (RuntimeException)jjte016;
                         }
                         if (jjte016 instanceof ParseException) {
                           throw (ParseException)jjte016;
                         }
                         throw (Error)jjte016;
                       } finally {
                         if (jjtc016) {
                           jjtree.closeNodeScope(jjtn016, true);
                         }
                       }
/*@egen*/                 
| < At_other > formula() 
| atom()
}


/**
 * this is a generic formula
 */
private void formula()           :
{/*@bgen(jjtree) Function */
  ASTFunction jjtn000 = new ASTFunction(this, JJTFUNCTION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) Function */
        try {
/*@egen*/
	{ t = getToken(0); }
  	// Optional parameters.
 
  	( LOOKAHEAD(2)
  		< OParen >
    	  	statement() ( < EOS > statement() )*
    	< CParen >
  	)?/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/ 
   	{ jjtn000.init(t.image); }/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

private void atom() :
{}
{
   value()
| < OParen > statement() <CParen >
}

private void value()  :
{
  Token t;
}
{
  	t = < Date_or_KW >/*@bgen(jjtree) ValueDateOrKW */
        {
          ASTValueDateOrKW jjtn001 = new ASTValueDateOrKW(this, JJTVALUEDATEORKW);
          boolean jjtc001 = true;
          jjtree.openNodeScope(jjtn001);
        }
        try {
/*@egen*//*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn001, true);
          jjtc001 = false;
        }
/*@egen*/
  	{ jjtn001.init(t.image); }/*@bgen(jjtree)*/
        } finally {
          if (jjtc001) {
            jjtree.closeNodeScope(jjtn001, true);
          }
        }
/*@egen*/               
|
	t = < String1 >/*@bgen(jjtree) ValueString */
        {
          ASTValueString jjtn002 = new ASTValueString(this, JJTVALUESTRING);
          boolean jjtc002 = true;
          jjtree.openNodeScope(jjtn002);
        }
        try {
/*@egen*//*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn002, true);
          jjtc002 = false;
        }
/*@egen*/
  	{ jjtn002.parseString(t.image, '"'); }/*@bgen(jjtree)*/
        } finally {
          if (jjtc002) {
            jjtree.closeNodeScope(jjtn002, true);
          }
        }
/*@egen*/             
|
	t = < String2 >/*@bgen(jjtree) ValueString */
        {
          ASTValueString jjtn003 = new ASTValueString(this, JJTVALUESTRING);
          boolean jjtc003 = true;
          jjtree.openNodeScope(jjtn003);
        }
        try {
/*@egen*//*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn003, true);
          jjtc003 = false;
        }
/*@egen*/
  	{ jjtn003.parseString(t.image, '{' ); }/*@bgen(jjtree)*/
        } finally {
          if (jjtc003) {
            jjtree.closeNodeScope(jjtn003, true);
          }
        }
/*@egen*/             
|
	t = < NumDoubleUS >/*@bgen(jjtree) ValueDouble */
        {
          ASTValueDouble jjtn004 = new ASTValueDouble(this, JJTVALUEDOUBLE);
          boolean jjtc004 = true;
          jjtree.openNodeScope(jjtn004);
        }
        try {
/*@egen*//*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn004, true);
          jjtc004 = false;
        }
/*@egen*/
  	{ jjtn004.parseDouble(t.image,'.'); }/*@bgen(jjtree)*/
        } finally {
          if (jjtc004) {
            jjtree.closeNodeScope(jjtn004, true);
          }
        }
/*@egen*/             
|
	t = < NumDoubleDE >/*@bgen(jjtree) ValueDouble */
        {
          ASTValueDouble jjtn005 = new ASTValueDouble(this, JJTVALUEDOUBLE);
          boolean jjtc005 = true;
          jjtree.openNodeScope(jjtn005);
        }
        try {
/*@egen*//*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn005, true);
          jjtc005 = false;
        }
/*@egen*/
  	{ jjtn005.parseDouble(t.image,','); }/*@bgen(jjtree)*/
        } finally {
          if (jjtc005) {
            jjtree.closeNodeScope(jjtn005, true);
          }
        }
/*@egen*/             
|
	t = < NumInteger >/*@bgen(jjtree) ValueInt */
        {
          ASTValueInt jjtn006 = new ASTValueInt(this, JJTVALUEINT);
          boolean jjtc006 = true;
          jjtree.openNodeScope(jjtn006);
        }
        try {
/*@egen*//*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn006, true);
          jjtc006 = false;
        }
/*@egen*/
  	{ jjtn006.parseInt(t.image); }/*@bgen(jjtree)*/
        } finally {
          if (jjtc006) {
            jjtree.closeNodeScope(jjtn006, true);
          }
        }
/*@egen*/          
|
	t = < Identifier >/*@bgen(jjtree) GetVariable */
        {
          ASTGetVariable jjtn007 = new ASTGetVariable(this, JJTGETVARIABLE);
          boolean jjtc007 = true;
          jjtree.openNodeScope(jjtn007);
        }
        try {
/*@egen*//*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn007, true);
          jjtc007 = false;
        }
/*@egen*/
  	{ jjtn007.init(t.image); }/*@bgen(jjtree)*/
        } finally {
          if (jjtc007) {
            jjtree.closeNodeScope(jjtn007, true);
          }
        }
/*@egen*/             	
}
